
//菜单2 终端参数设置
#include "Project698.h"
#include "../Display/Display.h"
#include "Menu.h"
#include "../Device/MEMRW.h"
#include "../Calculate/Calculate.h"
#include "../STM32F4xx/STM32F4xx_RTC.h"
#include "../Device/RTC.h"
#include "../DL698/DL698_DataDef.h"


const u8 pMenu_2[]=//集中器参数设置与查看
{
	"参数设置与查看\n\r"
	"  1.电能表参数设置\n\r"
	"  2.集中器时间设置\n\r"
	"  3.集中器地址设置\n\r"
	"  4.界面密码设置\n\r"
	"  5.无线公网设置\n\r"
	"  6.以太网设置\n\r"
};

const u8 pMenu_2_1[]=
{
	"电能表参数设置\n\r"
	"配置序号\n\r"
	"波特率\n\r"
	"通信端口\n\r"
	"通信规约\n\r"
	"通信地址\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_2[]=
{
	"集中器时间设置\n\r"
	"日期:\n\r"
	"时间:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_3[]=
{
	"通信地址设置\n\r"
	"地址\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_4[]=
{
	"菜单密码\n\r"
	"密码:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_5[]=
{
	"无线公网设置\n\r"
	"  1.通信模式设置\n\r"
	"  2.侦听端口设置\n\r"
	"  3.主站通信参数设置\n\r"
	"  4.APN设置\n\r"
	"  5.用户名设置\n\r"
	"  6.密码设置\n\r"
};

const u8 pMenu_2_5_1[]=
{
	"通信模式设置\n\r"
	"工作模式:\n\r"
	"在线方式:\n\r"
	"连接方式:\n\r"
	"应用方式:\n\r"
	"超时时间:\n\r"
	"重发次数:\n\r"
	"心跳周期:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_5_2[]=
{
	"侦听端口设置\n\r"
	"侦听端口:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_5_3[]=
{
	"主站IP及端口设置\n\r"
	"IP:\n\r"
	"端口:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_6[]=
{
	"以太网设置\n\r"
	"  1.通信配置\n\r"
	"  2.侦听端口设置\n\r"
	"  3.主站通信参数设置\n\r"
	"  4.终端IP设置\n\r"
	"  5.PPPoE用户名设置\n\r"
	"  6.PPPoE密码设置\n\r"
	"  7.MAC地址设置\n\r"
};

const u8 pMenu_2_6_1[]=
{
	"通信配置\n\r"
	"工作模式:\n\r"
	"连接方式:\n\r"
	"应用方式:\n\r"
	"超时时间:\n\r"
	"重发次数:\n\r"
	"心跳周期:\n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_6_4[]=
{
	"终端IP设置\n\r"
	"类型:\n\r"
	"IP  :\n\r"
	"子网:\n\r"
	"网关:\n\r"
	"      确认设置\n\r"
};


const u8 pMenu_2_6_6[]=
{
	"MAC地址设置\n\r"
	"  1.十进制\n\r"
	"  2.十六进制\n\r"
};

const u8 pMenu_2_6_6_1[]=
{
	"MAC地址设置\n\r"
	"MAC:\n\r"
	" \n\r"
	"      确认设置\n\r"
};

const u8 pMenu_2_6_6_2[]=
{
	"MAC地址设置\n\r"
	"MAC\n\r"
	"      确认设置\n\r"
};

const u8 IpTypeList[][7]=//IP类型列表
{
	"DHCP ",//0
	"静态 ",//1
	"PPPoE",//2
};


const u8 UnitList[][3]=//通用单位列表
{
	"s",     //0
	"次",    //1
};

const u8 OnlineModeList[][9]=//在线模式列表
{
	"永久在线", //0
	"被动激活", //1
};

const u8 WorkModeList[][7]=//工作模式列表
{
	"混合  ",   //0
	"客户机", //1
	"服务器", //2
};

const u8 ConnectList[][4]=//连接方式列表
{
	"TCP",   //0
	"UDP",   //1
};

const u8 ApplicationList[][7]=//连接方式列表
{
	"主备  ",   //0
	"多连接",   //1
};

const u8 CommunicationSpeedList[][7]=//通信速率列表
{
	"300 ",      //0
	"600  ",     //1
	"1200 ",     //2
	"2400 ",     //3
	"4800 ",     //4
	"7200 ",     //5
	"9600 ",     //6
	"19200",     //7
	"38400",     //8
	"57600",     //9
	"115200",    //10
	"自适应",    //255
};

const u8 ProtocolList[][13]=//通信协议列表
{
	"未知        ",//0 
	"DLT645-1997 ",//1 DL/T 645-1997
	"DLT645-2007 ",//2 DL/T 645-2007	
	"DL/T698.45  ",//3 DL/T698.45
	"CJ/T188-2004",//4 CJ/T 188-2004
};


//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_1
// Descriptions:        电能表参数设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_1(void)
{
//	u8 *p8;
//	u8 *p;
//	u8 *p8d;
//	u16 *p16;
//	u32 i=0;
//	u32 j=0;
//	u32 k;
//	u64 x;
//	u64 y;
//	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
//	{
//		case 0://任务0:初始化
//			Stack->MenuStack[MenuCount->Count].Task=1;
//			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_1);//显示菜单
//			//显示内存中数据
//			MenuCount->v1=8;
//			MenuCount->v2=11;
////			if(MenuCount->v3>MaxRS485AddCarrierPn)
////			{//MenuCount->v3记录配置序号的全局变量
////				MenuCount->v3=MaxRS485AddCarrierPn;
////			}
////			if(MenuCount->v3<1)
////			{//MenuCount->v3记录配置序号的全局变量
////				MenuCount->v3=1;
////			}
////			p=(u8 *)(ADDR_STRINGBUFF+(Stack->MenuStack[MenuCount->Count].EditRow)*84+4+MenuCount->v1)*2);
//			bcd_p8(p,MenuCount->v3,4);
//			if(MenuCount->v3)
//			{//配置号不为0时，显示相应的信息
//				//波特率
//				p8=Get_Element((u8*)ADDR_6000,2,2,LENper_6000);//计算元素地址,使用ADDR_128K_DATABUFF
//				if(p8)
//				{
//					if((p8[1]&0xff)=0xff)
//					{
//						DisplayString(2,6,0,(u8 *)ConnectList[11]);
//					}
//					else
//					{
//						DisplayString(2,6,0,(u8 *)ConnectList[p8[1]&0xff]);
//					}
//				}
//        //通信端口
//				p8=Get_Element((u8*)ADDR_6000,2,4,LENper_6000);//计算元素地址,使用ADDR_128K_DATABUFF
//				if(p8)
//				{
//					if(p8[1]>6)
//					
//				}
//				//规约类型
//				p8=Get_Element((u8*)ADDR_6000,2,3,LENper_6000);//计算元素地址,使用ADDR_128K_DATABUFF
//				if(p8)
//				{
//					DisplayString(4,8,0,(u8 *)ProtocolList[p8[1]&0xf]);
//				}
//				//通信地址
//				p8=Get_Element((u8*)ADDR_6000,2,3,LENper_6000);//计算元素地址,使用ADDR_128K_DATABUFF
//				if(p8)
//				{
//					p16=(u16 *)(ADDR_STRINGBUFF+5*84+4+8*2);
//					MR(ADDR_DATABUFF,(u32)(p8+2),6);
//					Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
//					x=MRR(ADDR_DATABUFF,6);
//					DisplayData(x,12,0,p16);
//				}
//			}
//			ArrowLR(Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
//			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
//			break;
//		case 1://任务1:选择
//			for(j=0;j<2;j++)
//			{
//					if((Comm_Ram->ButtonVal&0x08)!=0)
//					{//右键
//						switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
//						{
//							case 1:
//								break;
//							case 2:
//								break;
//							case 3:
//								break;
//							case 4:
//								break;
//							case 5:
//								break;
//							default:
//								break;
//						}
//					}
//					if((Comm_Ram->ButtonVal&0x04)!=0)
//					{//左键
//						switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
//						{
//							case 1:
//								break;
//							case 2:
//								break;
//							case 3:
//								break;
//							case 4:
//								break;
//							case 5:
//								break;
//							default:
//								break;
//						}
//					}
//					if((Comm_Ram->ButtonVal&0x10)!=0)
//					{//确认
//						switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
//						{
//							case 1:
//								break;
//							case 2:
//								break;
//							case 3:
//								break;
//							case 4:
//								break;
//							case 5:
//								break;
//							default:
//								break;
//						}
//						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
//					}
//					else
//					{
//						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
//						break;
//					}
//				}
//				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
//				{
//					Select(MenuCount->v2,MenuCount->v1);
//					UpDownSelect();
//					if((Comm_Ram->ButtonVal&0x10)!=0)
//					{//确认
//						switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
//						{
//							case 1:
//								break;
//							case 2:
//								break;
//							case 3:
//							case 4:
//								break;
//							case 5:
//								break;
//							default:
//								break;
//						}
//						Stack->MenuStack[MenuCount->Count].EditCol=0;
//						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
//					}
//					else
//					{
//						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
//						break;
//					}
//				}
//			}
//			if((Comm_Ram->ButtonVal&0x20)!=0)
//			{//返回
//				MenuDel();//返回上级菜单
//			}
//			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
//			break;
//		default:
//			break;
//	}
//	//通信端口号
//	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_2
// Descriptions:        集中器时间设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_2(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 Ln;
	u32 x;

#if ((Project/100)==3 && (USER/100)==5)//上海专变
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_2);//显示菜单
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=6;
			MenuCount->v2=13;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			//日期
			MR(ADDR_DATABUFF,ADDR_DL698YMDHMS,2);
			Data_Inverse(ADDR_DATABUFF,2);//数据倒序(高低字节调换),入口Le>=2
			x=MRR(ADDR_DATABUFF,2);//年
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			x-=0x2000;
			p=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+6*2);
			p[0*2]=((x>>4)&0xf)+0x30;
			p[1*2]=(x&0xf)+0x30;
			p[2*2]='-';
			x=MRR(ADDR_DL698YMDHMS+2,1);//月
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			p[3*2]=(x>>4)+0x30;
			p[4*2]=(x&0xf)+0x30;
			p[5*2]='-';
			x=MRR(ADDR_DL698YMDHMS+3,1);//日
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			p[6*2]=(x>>4)+0x30;
			p[7*2]=(x&0xf)+0x30;
			for(i=0;i<=7;i++)
			{
				p[i*2+1]=0x20;
			}
			//时间
			p=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+6*2);
			x=MRR(ADDR_DL698YMDHMS+4,1);//时
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			p[0*2]=(x>>4)+0x30;
			p[1*2]=(x&0xf)+0x30;
			p[2*2]=':';
			x=MRR(ADDR_DL698YMDHMS+5,1);//分
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			p[3*2]=(x>>4)+0x30;
			p[4*2]=(x&0xf)+0x30;
			p[5*2]=':';
			x=MRR(ADDR_DL698YMDHMS+6,1);//秒
			x=hex_bcd(x);//HEX数转为8位压缩BCD数
			p[6*2]=(x>>4)+0x30;
			p[7*2]=(x&0xf)+0x30;
			for(i=0;i<=7;i++)
			{
				p[i*2+1]=0x20;
			}
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=3)
					{
						DisplayString(Ln+3,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=6;
							MenuCount->v2=13;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=6;
							MenuCount->v2=13;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+6*2);
								if(p8[7*2]>=0x30 && p8[7*2]<0x39)
								{
									p8[7*2]++;
								}
								else if(p8[7*2]==0x39)
								{
									if(p8[6*2]>=0x30 && p8[6*2]<0x39)
									{
										p8[7*2]=0x30;
										p8[6*2]++;
									}
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==1) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==3) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==5) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==7) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==8) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==10) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==12))
								{
									if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>31)
									{//31日
										p8[7*2]=0x31;
										p8[6*2]=0x30;
									}
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==4) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==6) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==9) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==11))
								{
									if((p8[6*2]-0x30)*10+(p8[6*2]-0x30)*1>30)
									{//30日
										p8[7*2]=0x31;
										p8[6*2]=0x30;
									}
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==2))
								{
									if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>29)
									{//29日
										p8[7*2]=0x31;
										p8[6*2]=0x30;
									}
								}
								break;
							case 2:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+6*2);
								if(p8[7*2]>=0x30 && p8[7*2]<0x39)
								{
									p8[7*2]++;
								}
								else if(p8[7*2]==0x39)
								{
									if(p8[6*2]>=0x30 && p8[6*2]<0x39)
									{
										p8[7*2]=0x30;
										p8[6*2]++;
									}
								}
								if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>59)
								{
									p8[7*2]=0x30;
									p8[6*2]=0x30;
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+6*2);
								if(p8[6*2]>0x30 && p8[6*2]<=0x39)
								{
									if(p8[7*2]>0x30 && p8[7*2]<=0x39)
									{
										p8[7*2]--;
									}
									else if(p8[7*2]==0x30)
									{
										p8[7*2]=0x39;
										p8[6*2]--;
									}
								}
								else if(p8[6*2]==0x30)
								{
									if(p8[7*2]>0x31 && p8[7*2]<=0x39)
									{
										p8[7*2]--;
									}
									else if(p8[7*2]==0x31)
									{
										if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==1) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==3) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==5) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==7) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==8) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==10) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==12))
										{
											p8[7*2]=0x31;
											p8[6*2]=0x33;
										}
										if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==4) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==6) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==9) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==11))
										{
											p8[7*2]=0x30;
											p8[6*2]=0x33;
										}
										if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==2))
										{
											p8[7*2]=0x39;
											p8[6*2]=0x32;
										}
									}
								}
								break;
							case 2:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+6*2);
								if(p8[7*2]>0x30 && p8[7*2]<=0x39)
								{
									p8[7*2]--;
								}
								else if(p8[7*2]==0x30)
								{
									if(p8[6*2]>0x30 && p8[6*2]<=0x39)
									{
										p8[7*2]=0x39;
										p8[6*2]--;
									}
									else if(p8[6*2]==0x30)
									{
										p8[7*2]=0x39;
										p8[6*2]=0x35;
									}
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						if(Stack->MenuStack[MenuCount->Count].EditRow<3)
						{
							Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
							DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
						}
						else//if(Stack->MenuStack[MenuCount->Count].EditRow==3)
						{
							//保存设置的数据
							DisplayClrRow_4(Ln+3);//清屏幕显示的指定行(4个控制字不清)
							DisplayString(Ln+3,9,0,"OK");
							p8=(u8 *)(ADDR_RTCBUFF);
							p=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+6*2);
							p8[0]=(p[6*2]-0x30)*16+(p[7*2]-0x30)*1;//秒
							p8[1]=(p[3*2]-0x30)*16+(p[4*2]-0x30)*1;//分
							p8[2]=(p[0*2]-0x30)*16+(p[1*2]-0x30)*1;//时
							p=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+6*2);
							p8[4]=(p[6*2]-0x30)*16+(p[7*2]-0x30)*1;//日
							p8[5]=(p[3*2]-0x30)*16+(p[4*2]-0x30)*1;//月
							p8[6]=(p[0*2]-0x30)*16+(p[1*2]-0x30)*1;//年
//							WriteLPCRTC(ADDR_RTCBUFF);//写内部RTC
//							SyncLPCRTC();//同步内部RTC(读内部写外部)
							WriteRTC(ADDR_RTCBUFF);//写实时钟
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						if(Stack->MenuStack[MenuCount->Count].EditRow<3)
						{
							p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
							p16[0]=0x2020;
							p16[1]=0x2020;
							p16[2]=32;//'左右箭头'
							p16[3]=33;
						}
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+6*2);
								if((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1>12)
								{
									p8[3*2]=0x30;
									p8[4*2]=0x31;
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==1) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==3) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==5) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==7) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==8) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==10) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==12))
								{
									if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>31)
									{//31日
										p8[7*2]=0x31;
										p8[6*2]=0x30;
									}
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==4) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==6) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==9) || ((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==11))
								{
									if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>30)
									{//30日
										p8[7*2]=0x31;
										p8[6*2]=0x30;
									}
								}
								if(((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1==2))
								{
									if((((p8[0*2]-0x30)*10+(p8[1*2]-0x30))%4)==0x0)
									{//闰年2月有29日
										if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>29)
										{//29日
											p8[7*2]=0x31;
											p8[6*2]=0x30;
										}
									}
									else
									{//平年2月只有28日
										if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>28)
										{//28日
											p8[7*2]=0x31;
											p8[6*2]=0x30;
										}
									}
								}
								break;
							case 2:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+6*2);
								if((p8[0*2]-0x30)*10+(p8[1*2]-0x30)*1>23)
								{
									p8[0*2]=0x30;
									p8[1*2]=0x30;
								}
								if((p8[3*2]-0x30)*10+(p8[4*2]-0x30)*1>59)
								{
									p8[3*2]=0x30;
									p8[4*2]=0x30;
								}
								if((p8[6*2]-0x30)*10+(p8[7*2]-0x30)*1>59)
								{
									p8[7*2]=0x30;
									p8[6*2]=0x30;
								}
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}	  
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_3
// Descriptions:        集中器地址设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_3(void)
{
	u8 *p8;
	u8 *p;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u64 x;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_3);//显示菜单
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=4;
			MenuCount->v2=15;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			//显示内存中数据
			//通信地址
				p16=(u16 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+(MenuCount->v1)*2);
				MR(ADDR_DATABUFF,ADDR_4001+2,6);
				Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
				x=MRR(ADDR_DATABUFF,6);
				DisplayData(x,12,0,p16);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=2)
					{
						DisplayString(Ln+2,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=4;
							MenuCount->v2=15;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+4*2);
								p8_add1(p8,12);
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+4*2);
								p8_sub1(p8,12);
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+4*2);
								//通信地址BCD占6个字节，判断内存数据如果有错则初始化
								for(i=0;i<=11;i++)
								{
									if(p8[i*2]>0x39 || p8[i*2]<0x30 || p8[i*2+1]!=0x20)
									{
										break;
									}
								}
								if(i!=12)
								{
									bcd_p8(p8,1,12);
								}
								break;
							case 2:
								DisplayClrRow_4(Ln+2);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+2,9,0,"OK");
								//保存设置的数据
								p8=(u8 *)ADDR_DATABUFF;
								p=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+4*2);
								p8[0]=(p[0*2]-0x30)*16+(p[1*2]-0x30)*1;
								p8[1]=(p[2*2]-0x30)*16+(p[3*2]-0x30)*1;
								p8[2]=(p[4*2]-0x30)*16+(p[5*2]-0x30)*1;
								p8[3]=(p[6*2]-0x30)*16+(p[7*2]-0x30)*1;
								p8[4]=(p[8*2]-0x30)*16+(p[9*2]-0x30)*1;
								p8[5]=(p[10*2]-0x30)*16+(p[11*2]-0x30)*1;
								MW(ADDR_DATABUFF,ADDR_4001+2,6);//写通信地址
							
//											p=(u8 *)(ADDR_STRINGBUFF+(6-Stack->MenuStack[MenuCount->Count].MoveRow)*84+4+8*2);
//											for(i=0;i<=5;i++)
//											{
//												if(p[(2*i)*2]>=0x30 && p[(2*i)*2]<=0x39)
//												{
//													if(p[(2*i+1)*2]>=0x30 && p[(2*i+1)*2]<=0x39)
//													{
//														p8[i]=(p[(2*i)*2]-0x30)*16+(p[(2*i+1)*2]-0x30)*1;
//													}
//													if(p[(2*i+1)*2]>=0x41 && p[(2*i+1)*2]<=0x46)
//													{
//														p8[i]=(p[(2*i)*2]-0x30)*16+(p[(2*i+1)*2]-0x30)*1;
//													}
//												}
//												if(p[(2*i)*2]>=0x41 && p[(2*i)*2]<=0x46)
//												{
//													if(p[(2*i+1)*2]>=0x30 && p[(2*i+1)*2]<=0x39)
//													{
//														p8[i]=(p[(2*i)*2]-0x30)*16+(p[(2*i+1)*2]-0x30)*1;
//													}
//													if(p[(2*i+1)*2]>=0x41 && p[(2*i+1)*2]<=0x46)
//													{
//														p8[i]=(p[(2*i)*2]-0x30)*16+(p[(2*i+1)*2]-0x30)*1;
//													}
//												}
//											}	
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+((Ln+1))*84+4+(MenuCount->v1)*2);
								//通信地址BCD占6个字节，判断内存数据如果有错则初始化
								for(i=0;i<=11;i++)
								{
									if(p8[i*2]>0x39 || p8[i*2]<0x30)
									{
										break;
									}
								}
								if(i!=12)
								{
									bcd_p8(p8,1,12);
								}
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_4
// Descriptions:        界面密码设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_4(void)
{
	u32 x;
	u32 i;
	u32 j;
	u32 k;
	u8 *p8;
	u16 *p16;
	u32 *p32;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_4);//显示菜单
			/*显示内存中数据*/
//			x=MRR(ADDR_MenuKey,3);
			p16=(u16 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
			DisplayData(x,6,0,p16);
			MenuCount->v1=5;
			MenuCount->v2=10;
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=2)
					{
						DisplayString(Ln+2,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=5;
							MenuCount->v2=10;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								p8_add1(p8,6);
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								p8_sub1(p8,6);
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 2:
								DisplayString(Ln+2,6,0,"   OK   ");
								/*保存设置的数据*/
								p32=(u32 *)ADDR_DATABUFF;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								p32[0]=(p8[0]-0x30)*16*16*16*16*16+(p8[2]-0x30)*16*16*16*16+(p8[4]-0x30)*16*16*16+(p8[6]-0x30)*16*16+(p8[8]-0x30)*16+(p8[10]-0x30)*1;
//								MW(ADDR_DATABUFF,ADDR_MenuKey,3);//写菜单密码
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5_1
// Descriptions:        通信模式设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5_1(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 x;
	u32 i;
	u32 j;
	u32 k;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5_1);//显示菜单
			//工作模式:混合模式（0），客户机模式（1），服务器模式（2）
			p8=Get_Element((u8*)ADDR_4500_2,1,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+1,10,0,(u8 *)WorkModeList[p8[1]&0x03]);
			}
		  //在线方式:永久在线（0），被动激活（1）
			p8=Get_Element((u8*)ADDR_4500_2,2,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+2,10,0,(u8 *)OnlineModeList[p8[1]&0x03]);
			}
		  //连接方式:TCP（0），UDP（1）
			p8=Get_Element((u8*)ADDR_4500_2,3,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+3,10,0,(u8 *)ConnectList[p8[1]&0x03]);
			}
		  //连接应用方式:主备模式（0），多连接模式（1）
			p8=Get_Element((u8*)ADDR_4500_2,4,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+4,10,0,(u8 *)ApplicationList[p8[1]&0x03]);
			}
		  //超时时间及重发次数：bit7~bit2：超时时间（秒）bit1~bit0：重发次数
			p8=Get_Element((u8*)ADDR_4500_2,11,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				//超时时间（秒）
				i=(p8[2]>>2);
				p=(u8*)ADDR_STRINGBUFF+(Ln+5)*84+4+10*2;
				bcd_p8(p,i,3);
				DisplayString(Ln+5,13,0,(u8 *)UnitList[0]);//0 s
				//重发次数
				i=(p8[2]&0x03);
				p=(u8*)ADDR_STRINGBUFF+(Ln+6)*84+4+10*2;
				bcd_p8(p,i,1);
				DisplayString(Ln+6,11,0,(u8 *)UnitList[1]);//1 次
			}
			//心跳周期(秒)  long-unsigned
			p8=Get_Element((u8*)ADDR_4500_2,12,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
        i=p8[1];
				i<<=8;
				i|=p8[2];
				p=(u8*)ADDR_STRINGBUFF+(Ln+7)*84+4+10*2;
				bcd_p8(p,i,5);
			  DisplayString(Ln+7,15,0,(u8 *)UnitList[0]);//0 s				
			}
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=10;
			MenuCount->v2=17;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=8)
					{
						DisplayString(Ln+8,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
							MenuCount->v1=10;
							MenuCount->v2=15;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2://在线方式:永久在线（0），被动激活（1）
							MenuCount->v1=10;
							MenuCount->v2=17;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3://连接方式:TCP（0），UDP（1）
							MenuCount->v1=10;
							MenuCount->v2=12;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 4://连接应用方式:主备模式（0），多连接模式（1）
							MenuCount->v1=10;
							MenuCount->v2=15;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 5://超时时间
							MenuCount->v1=10;
							MenuCount->v2=12;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 6://重发次数
							MenuCount->v1=10;
							MenuCount->v2=10;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 7://心跳周期(秒)  long-unsigned
							MenuCount->v1=10;
							MenuCount->v2=14;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 8:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x46://混
										i=1;
										break;
									case 0xF8://客
										i=2;
										break;
									case 0x7A://服
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)WorkModeList[i]);
								break;
							case 2://在线方式:永久在线（0），被动激活（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x8E://永
										i=1;
										break;
									case 0x8C://被
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)OnlineModeList[i]);//1 永久在线 2 被动激活 3 时段在线
								break;
							case 3://连接方式:TCP（0），UDP（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x54://TCP
										i=1;
										break;
									case 0x55://UDP
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ConnectList[i]);
								break;
							case 4://连接应用方式:主备模式（0），多连接模式（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x30://主
										i=1;
										break;
									case 0x82://多
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ApplicationList[i]);
								break;
							case 5://超时时间
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x<63)
								{
									p8_add1(p8,3);
								}
								else
								{
									bcd_p8(p8,0,3);
								}
								break;
							case 6://重发次数
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x<3)
								{
									p8_add1(p8,1);
								}
								else
								{
									bcd_p8(p8,0,1);
								}
								break;
							case 7://心跳周期(秒)  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x46://混
										i=2;
										break;
									case 0xF8://客
										i=0;
										break;
									case 0x7A://服
										i=1;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)WorkModeList[i]);
								break;
							case 2://在线方式:永久在线（0），被动激活（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x8E://永
										i=1;
										break;
									case 0x8C://被
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)OnlineModeList[i]);//1 永久在线 2 被动激活 3 时段在线
								break;
							case 3://连接方式:TCP（0），UDP（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x54://TCP
										i=1;
										break;
									case 0x55://UDP
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ConnectList[i]);
								break;
							case 4://连接应用方式:主备模式（0），多连接模式（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x30://主
										i=1;
										break;
									case 0x82://多
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ApplicationList[i]);
								break;
							case 5://超时时间
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x>0)
								{
									p8_sub1(p8,3);
								}
								else
								{
									bcd_p8(p8,63,3);
								}
								break;
							case 6://重发次数
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x>0)
								{
									p8_sub1(p8,1);
								}
								else
								{
									bcd_p8(p8,3,1);
								}
								break;
							case 7://心跳周期(秒)  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 5://超时时间
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 6://重发次数
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 7://心跳周期(秒)  long-unsigned
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 8://确认设置
								DisplayClrRow_4(Ln+Stack->MenuStack[MenuCount->Count].EditRow);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,9,0,"OK");
								//保存设置的数据
								//1.工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								x=Get_ElementADDR(ADDR_4500_2,1,0,LENmax_4500_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+10*2);
									switch(p8[0])
									{
										case 0x46://混
											i=0;
											break;
										case 0xF8://客
											i=0x01;
											break;
										case 0x7A://服
											i=0x02;
											break;
										default:
											break;
									}
									MWR(i,x+1,1);
								}
								
								//2.在线方式:永久在线（0），被动激活（1）
								x=Get_ElementADDR(ADDR_4500_2,2,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+2)*84+4+10*2;
									switch(p8[0])
									{
										case 0x8E://永
											i=0;
											break;
										case 0x8C://被
											i=0x01;
											break;
										default:
											break;
									}
									MWR(i,x+1,1);
								}
								//3.连接方式:TCP（0），UDP（1）
								x=Get_ElementADDR(ADDR_4500_2,3,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+3)*84+4+10*2;
									switch(p8[0])
									{
										case 0x54://TCP
											i=0;
											break;
										case 0x55://UDP
											i=0x01;
											break;
									}
									MWR(i,x+1,1);
								}
								//4.连接应用方式:主备模式（0），多连接模式（1）
								x=Get_ElementADDR(ADDR_4500_2,4,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)								
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+4)*84+4+10*2;
									switch(p8[0])
									{
										case 0x30://主
											i=0;
											break;
										case 0x82://多
											i=0x01;
											break;
									}
									MWR(i,x+1,1);									
								}
								//5.超时时间及重发次数：bit7~bit2：超时时间（秒）bit1~bit0：重发次数
								x=Get_ElementADDR(ADDR_4500_2,11,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									//超时时间（秒）
									p8=(u8*)ADDR_STRINGBUFF+(Ln+5)*84+4+10*2;
									i=p8_bcd(p8,3);
									i<<=2;
									//重发次数
									p8=(u8*)ADDR_STRINGBUFF+(Ln+6)*84+4+10*2;
									k=p8_bcd(p8,1);
									i|=k;
									MWR(i,x+2,1);									
								}
								//7.心跳周期(秒)  long-unsigned
								x=Get_ElementADDR(ADDR_4500_2,12,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+7)*84+4+10*2;
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);									
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 5://超时时间
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x>63)
								{
									bcd_p8(p8,0,3);
								}
								break;
							case 6://重发次数
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x>3)
								{
									bcd_p8(p8,0,1);
								}
								break;
							case 7://7.心跳周期(秒)
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5_2
// Descriptions:        侦听端口设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5_2(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 x;
	u32 i;
	u32 j;
	u32 k;
	u32 Ln;	
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5_2);//显示菜单
			p8=Get_Element((u8*)ADDR_4500_2,5,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{
				if(p8[1])
				{//数组个数不为0，显示第1个侦听端口
					i=p8[3];
					i<<=8;
					i|=p8[4];
					p=(u8*)ADDR_STRINGBUFF+(Ln+1)*84+4+9*2;
					bcd_p8(p,i,5);					
				}
			}
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=9;
			MenuCount->v2=13;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{	
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=2)
					{
						DisplayString(Ln+2,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{					
						case 1://侦听端口
							MenuCount->v1=9;
							MenuCount->v2=13;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2://确认设置
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;						
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://侦听端口  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}							
					}						
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://侦听端口  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;
							default:
								break;
						}
					}						
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 2:
								DisplayClrRow_4(Ln+2);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+2,9,0,"OK");
								//保存设置的数据
							  //侦听端口
								x=Get_ElementADDR(ADDR_4500_2,5,1,LENmax_4500_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+9*2);
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);
								}							
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}										
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}	
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0						
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;			
	}		
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5_3
// Descriptions:        主站通信参数设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5_3(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 x;
	u32 Ln;
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5_3);//显示菜单
			//IP
			p8=Get_Element((u8*)ADDR_4500_3,1,1,LENmax_4500_3);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{//IP
				p=(u8*)ADDR_STRINGBUFF+(Ln+1)*84+4+3*2;
				for(i=0;i<=3;i++)
				{
					bcd_p8(p+i*8,p8[i+2],3);
				}
				for(i=0;i<=2;i++)
				{
					p[3*2+i*8]='.';
					p[3*2+i*8+1]=0x20;
				}
			}
			//端口
			p8=Get_Element((u8*)ADDR_4500_3,1,2,LENmax_4500_3);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{//端口
				p=(u8*)ADDR_STRINGBUFF+(Ln+2)*84+4+5*2;
				i=p8[1];
				i<<=8;
				i|=p8[2];
				bcd_p8(p,i,5);
			}				
			MenuCount->v1=3;
			MenuCount->v2=19;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);		
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=3)
					{
						DisplayString(Ln+3,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{	
						case 1://IP
							MenuCount->v1=3;
							MenuCount->v2=19;
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							break;
						case 2://端口
							MenuCount->v1=5;
							MenuCount->v2=9;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;						
					}						
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP 按右键不加
								break;	
							case 2://端口
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;	
							default:
								break;						
						}							
					}						
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP 按左键不减
								break;	
							case 2://端口
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;					
							default:
								break;											
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								break;
							case 2://端口
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 3:
								DisplayClrRow_4(Ln+3);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+3,9,0,"OK");
								//保存设置的数据
								x=Get_ElementADDR(ADDR_4500_3,1,1,LENmax_4500_3);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)ADDR_DATABUFF;
									p=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+3*2);
									for(i=0;i<=3;i++)
									{
										p8[i]=p8_bcd(p+8*i,3);
									}
									MW(ADDR_DATABUFF,x+2,4);//写IP
								}	
								x=Get_ElementADDR(ADDR_4500_3,1,2,LENmax_4500_3);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);//写端口
								}							
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+3*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								x=p8_bcd(p8+12*2,3);
								if(x>255)
								{
									bcd_p8(p8+12*2,0,3);
								}
								break;
							case 2:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}							
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}				
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5_4
// Descriptions:        APN设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5_4(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 k;
	u32 MinLn=4;//软键盘最小行号
	u32 MaxLn=8;//软键盘最大行号
	u32 LastLnMaxCol=14;//软键盘的最后一行最大列号
	u32 MinCol=0;//软键盘最小列号
	u32 MaxCol=19;//软键盘最大列号
	u32 EditLn=2;
	u32 EditCol=2;
	u32 EditLength=16;
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	u8 * p8d;
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=2;
			p8=" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`!@#$%^&*()_+-={}[]|:;'\",.?/\\<>";
			DisplayClr();//清全屏
			DisplayString(0,6,0,"APN设置");
			DisplayString(MinLn,MinCol,0,p8);
			p8=Get_Element((u8*)ADDR_4500_2,6,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{
				MenuCount->v3=p8[1];//APN长度
				p8+=2;
				if(MenuCount->v3>16)
				{//暂固定APN长度为16字节
					MenuCount->v3=16;
					
				}
				MC(0,ADDR_DATABUFF+MenuCount->v3,1);
				MR(ADDR_DATABUFF,(u32)p8,MenuCount->v3);
			}
			p=(u8 *)ADDR_DATABUFF;
			DisplayString(EditLn,EditCol,0,p);
			
			Comm_Ram->DisplayScanTimer=0;//2 显示扫描10MS定时器
			NegativeLnCol(EditLn,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
			break;
		case 1://任务1：键盘选择
			KeyboardSelect(MinLn,MaxLn,LastLnMaxCol,MinCol,MaxCol,EditLn,EditCol);//键盘选择
			break;
		case 2://任务2：编辑框选择
			if((Comm_Ram->ButtonVal&0x01)!=0)
			{//下键
				Stack->MenuStack[MenuCount->Count].EditRow = 4;
				Stack->MenuStack[MenuCount->Count].EditCol = 0;
				p16=(u16 *)(ADDR_STRINGBUFF+(Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(Stack->MenuStack[MenuCount->Count].EditCol)*2);
				*p16|=0x8000;
				Stack->MenuStack[MenuCount->Count].Task = 1;
			}
			else
			{
				if((Comm_Ram->ButtonVal&0x08)!=0)
				{//右键
					Stack->MenuStack[MenuCount->Count].MoveRow ++;
					if(Stack->MenuStack[MenuCount->Count].MoveRow == EditLength)
					{
						Stack->MenuStack[MenuCount->Count].MoveRow = 0;
					}
				}
				if((Comm_Ram->ButtonVal&0x04)!=0)
				{//左键
					if(Stack->MenuStack[MenuCount->Count].MoveRow > 0)
					{
						Stack->MenuStack[MenuCount->Count].MoveRow --;
					}
					else
					{
						Stack->MenuStack[MenuCount->Count].MoveRow = EditLength-1;
					}
				}
				NegativeLnCol(EditLn,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
				if((Comm_Ram->ButtonVal&0x10)!=0)
				{//确认
					//保存数据
					p8=(u8 *)ADDR_DATABUFF;
					p=(u8 *)(ADDR_STRINGBUFF+(EditLn)*84+4+(EditCol)*2);
					for(i=0;i<=15;i++)
					{
						if(p[i*2]!=0x20 && p[i*2]!=0x00)
						{
							p8[i]=p[i*2];
						}
						else
						{
							p8[i]=0;
							break;
						}
					}
					k=Get_ElementADDR(ADDR_128KDATABUFF,6,0,0);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
					if(k)
					{
						MWR(i,k+1,1);//APN长度
						MW(ADDR_DATABUFF,k+2,i);
					}	
					//设置成功提示ＯＫ
					DisplayClrRow(1,9);
					DisplayString(1,0,0,p8);
					DispalyAlign(1,0,2);//行显示对齐(1左对齐,2居中,3右对齐)
					DisplayString(4,7,0,"设置OK");
					DisplayString(5,4,0,"按任意键退出");
					Stack->MenuStack[MenuCount->Count].Task=3;
				}
				if((Comm_Ram->ButtonVal&0x20)!=0)
				{//返回
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
					p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用，0=否，1=是
					p8d[0]=1;//菜单显示顶、底行用，0=否，1=是
#endif
					Stack->MenuStack[MenuCount->Count].MoveRow =0;
					MenuDel();//返回上级菜单
				}
			}
			Comm_Ram->ButtonVal&=~0x3D;//键使用后清0
			break;
		case 3://设置成功后按任意键退出
			Stack->MenuStack[MenuCount->Count].MoveRow =0;
			if((Comm_Ram->ButtonVal&0x3F)!=0)
			{
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
				p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用，0=否，1=是
				p8d[0]=1;//菜单显示顶、底行用，0=否，1=是
#endif
				Stack->MenuStack[MenuCount->Count].MoveRow =0;
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x3F;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5_5
// Descriptions:        用户名设置、密码设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5_5(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 x;
	u32 MinLn=4;//软键盘最小行号
	u32 MaxLn=8;//软键盘最大行号
	u32 LastLnMaxCol=14;//软键盘的最后一行最大列号
	u32 MinCol=0;//软键盘最小列号
	u32 MaxCol=19;//软键盘最大列号
	u32 EditCol=0;
	u32 EditLength=20;
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	u8 * p8d;
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0：初始化
			Stack->MenuStack[MenuCount->Count].Task=2;
			p8=" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`!@#$%^&*()_+-={}[]|:;'\",.?/\\<>";
			DisplayClr();//清全屏
			DisplayString(MinLn,MinCol,0,p8);
			switch(Stack->MenuStack[MenuCount->Count-1].EditRow+Stack->MenuStack[MenuCount->Count-1].MoveRow)
			{
				case 5:
					DisplayString(0,5,0,"用户名设置");
					p=Get_Element((u8*)ADDR_4500_2,7,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
					if(p)
					{
						i=p[1];//用户名长度
						p+=2;
						if(i>32)
						{//暂固定用户名长度32字节
							i=32;
						}
						MC(0,ADDR_DATABUFF+i,1);
						MR(ADDR_DATABUFF,(u32)p,i);						
					}
					p8=(u8 *)ADDR_DATABUFF;
					DisplayString(MenuCount->v1,EditCol,0,p8);
				break;
				case 6:
					DisplayString(0,6,0,"密码设置");
					p=Get_Element((u8*)ADDR_4500_2,8,0,LENmax_4500_2);//计算元素地址,使用ADDR_128K_DATABUFF
					if(p)
					{
						i=p[1];//用户名长度
						p+=2;
						if(i>32)
						{//暂固定用户名长度32字节
							i=32;
						}
						MC(0,ADDR_DATABUFF+i,1);
						MR(ADDR_DATABUFF,(u32)p,i);						
					}
					p8=(u8 *)ADDR_DATABUFF;
					DisplayString(MenuCount->v1,EditCol,0,p8);
					break;
			}			
			Comm_Ram->DisplayScanTimer=0;//2 显示扫描10Ms定时器
			NegativeLnCol(MenuCount->v1,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
			break;
		case 1://任务1：键盘选择
			KeyboardSelect(MinLn,MaxLn,LastLnMaxCol,MinCol,MaxCol,MenuCount->v1,EditCol);//键盘选择
			break;
		case 2://任务2：编辑框选择
			if((Comm_Ram->ButtonVal&0x01)!=0)
			{//下键
				Stack->MenuStack[MenuCount->Count].EditRow = 4;
				Stack->MenuStack[MenuCount->Count].EditCol = 0;
				p16=(u16 *)(ADDR_STRINGBUFF+(Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(Stack->MenuStack[MenuCount->Count].EditCol)*2);
				*p16|=0x8000;
				Stack->MenuStack[MenuCount->Count].Task = 1;
			}
			else
			{
				if((Comm_Ram->ButtonVal&0x08)!=0)
				{//右键
					switch(MenuCount->v1)
					{
						case 1:
							Stack->MenuStack[MenuCount->Count].MoveRow ++;
							if(Stack->MenuStack[MenuCount->Count].MoveRow == EditLength)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 0;
								(MenuCount->v1)++;
							}
							break;
						case 2:
							Stack->MenuStack[MenuCount->Count].MoveRow ++;
							if(Stack->MenuStack[MenuCount->Count].MoveRow == 12)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 0;
								(MenuCount->v1)--;
							}
							break;
					}
				}
				if((Comm_Ram->ButtonVal&0x04)!=0)
				{//左键
					switch(MenuCount->v1)
					{
						case 1:
							if(Stack->MenuStack[MenuCount->Count].MoveRow > 0)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow --;
							}
							else
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 11;
								(MenuCount->v1)++;
							}
							break;
						case 2:
							if(Stack->MenuStack[MenuCount->Count].MoveRow > 0)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow --;
							}
							else
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = EditLength-1;
								(MenuCount->v1)--;
							}
							break;
					}
				}
				NegativeLnCol(MenuCount->v1,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
				if((Comm_Ram->ButtonVal&0x10)!=0)
				{//确认
					//保存数据
					p8=(u8 *)ADDR_DATABUFF;
					p=(u8 *)(ADDR_STRINGBUFF+1*84+4+(EditCol)*2);
					for(i=0;i<=19;i++)
					{
						if(p[i*2]==0x20 || p[i*2]==0x00)
						{
							p[i*2]=0x00;
						}
						p8[i]=p[i*2];
					}
					p=(u8 *)(ADDR_STRINGBUFF+2*84+4+0*2);
					for(i=0;i<=11;i++)
					{
						if(p[i*2]==0x20 || p[i*2]==0x00)
						{
							p[i*2]=0x00;
						}
						p8[20+i]=p[i*2];
					}
					for(i=0;i<=31;i++)
					{
						if(p8[i]==0x00)
						{
							break;
						}
					}
					switch(Stack->MenuStack[MenuCount->Count-1].EditRow)
					{
						case 5:
							x=Get_ElementADDR(ADDR_4500_2,7,0,LENmax_4500_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
							if(x)
							{
								MWR(i,x+1,1);//长度
								MW(ADDR_DATABUFF,x+2,i);
							}
							break;
						case 6:
							x=Get_ElementADDR(ADDR_4500_2,8,0,LENmax_4500_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
							if(x)
							{
								MWR(i,x+1,1);//长度
								MW(ADDR_DATABUFF,x+2,i);
							}
							break;
					}
					//设置成功提示OK
					DisplayClrRow(1,9);
					DisplayString(1,2,0,p8);
					DispalyAlign(1,0,2);//行显示对其(1左对齐,2居中,3右对齐)
					DispalyAlign(2,0,2);//行显示对其(1左对齐,2居中,3右对齐)
					DisplayString(4,7,0,"设置OK");
					DisplayString(5,4,0,"按任意键退出");
					Stack->MenuStack[MenuCount->Count].Task=3;
				}
				if((Comm_Ram->ButtonVal&0x20)!=0)
				{//返回
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
					p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用 0=否1=是
					p8d[0]=1;//菜单显示顶、底行用 0=否1=是
#endif
					Stack->MenuStack[MenuCount->Count].MoveRow =0;
					MenuDel();//返回上级菜单
				}
			}
			Comm_Ram->ButtonVal&=~0x3D;//键使用后清0
			break;
		case 3://设置成功按任意键退出
			if((Comm_Ram->ButtonVal&0x3F)!=0)
			{
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
				p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用 0=否1=是
				p8d[0]=1;//菜单显示顶、底行用 0=否1=是
#endif
				Stack->MenuStack[MenuCount->Count].MoveRow =0;
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x3F;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_1
// Descriptions:        通信配置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_1(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 x;
	u32 i;
	u32 j;
	u32 k;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6_1);//显示菜单
			//工作模式:混合模式（0），客户机模式（1），服务器模式（2）
			p8=Get_Element((u8*)ADDR_4510_2,1,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+1,10,0,(u8 *)WorkModeList[p8[1]&0x03]);
			}
		  //连接方式:TCP（0），UDP（1）
			p8=Get_Element((u8*)ADDR_4510_2,2,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+2,10,0,(u8 *)ConnectList[p8[1]&0x03]);
			}
		  //连接应用方式:主备模式（0），多连接模式（1）
			p8=Get_Element((u8*)ADDR_4510_2,3,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				DisplayString(Ln+3,10,0,(u8 *)ApplicationList[p8[1]&0x03]);
			}
		  //超时时间及重发次数：bit7~bit2：超时时间（秒）bit1~bit0：重发次数
			p8=Get_Element((u8*)ADDR_4510_2,7,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				//超时时间（秒）
				i=(p8[2]>>2);
				p=(u8*)ADDR_STRINGBUFF+(Ln+4)*84+4+10*2;
				bcd_p8(p,i,3);
				DisplayString(Ln+4,13,0,(u8 *)UnitList[0]);//0 s
				//重发次数
				i=(p8[2]&0x03);
				p=(u8*)ADDR_STRINGBUFF+(Ln+5)*84+4+10*2;
				bcd_p8(p,i,1);
				DisplayString(Ln+5,11,0,(u8 *)UnitList[1]);//1 次
			}
			//心跳周期(秒)  long-unsigned
			p8=Get_Element((u8*)ADDR_4510_2,8,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
        i=p8[1];
				i<<=8;
				i|=p8[2];
				p=(u8*)ADDR_STRINGBUFF+(Ln+6)*84+4+10*2;
				bcd_p8(p,i,5);
			  DisplayString(Ln+6,15,0,(u8 *)UnitList[0]);//0 s				
			}
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=10;
			MenuCount->v2=17;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=7)
					{
						DisplayString(Ln+7,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
							MenuCount->v1=10;
							MenuCount->v2=15;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2://连接方式:TCP（0），UDP（1）
							MenuCount->v1=10;
							MenuCount->v2=12;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3://连接应用方式:主备模式（0），多连接模式（1）
							MenuCount->v1=10;
							MenuCount->v2=15;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 4://超时时间
							MenuCount->v1=10;
							MenuCount->v2=12;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 5://重发次数
							MenuCount->v1=10;
							MenuCount->v2=10;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 6://心跳周期(秒)  long-unsigned
							MenuCount->v1=10;
							MenuCount->v2=14;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 7:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x46://混
										i=1;
										break;
									case 0xF8://客
										i=2;
										break;
									case 0x7A://服
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)WorkModeList[i]);
								break;
							case 2://连接方式:TCP（0），UDP（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x54://TCP
										i=1;
										break;
									case 0x55://UDP
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ConnectList[i]);
								break;
							case 3://连接应用方式:主备模式（0），多连接模式（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x30://主
										i=1;
										break;
									case 0x82://多
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ApplicationList[i]);
								break;
							case 4://超时时间
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x<63)
								{
									p8_add1(p8,3);
								}
								else
								{
									bcd_p8(p8,0,3);
								}
								break;
							case 5://重发次数
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x<3)
								{
									p8_add1(p8,1);
								}
								else
								{
									bcd_p8(p8,0,1);
								}
								break;
							case 6://心跳周期(秒)  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x46://混
										i=2;
										break;
									case 0xF8://客
										i=0;
										break;
									case 0x7A://服
										i=1;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)WorkModeList[i]);
								break;
							case 2://连接方式:TCP（0），UDP（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x54://TCP
										i=1;
										break;
									case 0x55://UDP
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ConnectList[i]);
								break;
							case 3://连接应用方式:主备模式（0），多连接模式（1）
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								switch(p8[0])
								{
									case 0x30://主
										i=1;
										break;
									case 0x82://多
										i=0;
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,10,0,(u8 *)ApplicationList[i]);
								break;
							case 4://超时时间
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x>0)
								{
									p8_sub1(p8,3);
								}
								else
								{
									bcd_p8(p8,63,3);
								}
								break;
							case 5://重发次数
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x>0)
								{
									p8_sub1(p8,1);
								}
								else
								{
									bcd_p8(p8,3,1);
								}
								break;
							case 6://心跳周期(秒)  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 4://超时时间
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 5://重发次数
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 6://心跳周期(秒)  long-unsigned
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 7://确认设置
								DisplayClrRow_4(Ln+Stack->MenuStack[MenuCount->Count].EditRow);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,9,0,"OK");
								//保存设置的数据
								//1.工作模式:混合模式（0），客户机模式（1），服务器模式（2）
								x=Get_ElementADDR(ADDR_4510_2,1,0,LENmax_4510_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+10*2);
									switch(p8[0])
									{
										case 0x46://混
											i=0;
											break;
										case 0xF8://客
											i=0x01;
											break;
										case 0x7A://服
											i=0x02;
											break;
										default:
											break;
									}
									MWR(i,x+1,1);
									
								}
								//2.连接方式:TCP（0），UDP（1）
								x=Get_ElementADDR(ADDR_4510_2,2,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+2)*84+4+10*2;
									switch(p8[0])
									{
										case 0x54://TCP
											i=0;
											break;
										case 0x55://UDP
											i=0x01;
											break;
									}
									MWR(i,x+1,1);
								}
								//3.连接应用方式:主备模式（0），多连接模式（1）
								x=Get_ElementADDR(ADDR_4510_2,3,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)								
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+3)*84+4+10*2;
									switch(p8[0])
									{
										case 0x30://主
											i=0;
											break;
										case 0x82://多
											i=0x01;
											break;
									}
									MWR(i,x+1,1);
								}
								//4.超时时间及重发次数：bit7~bit2：超时时间（秒）bit1~bit0：重发次数
								x=Get_ElementADDR(ADDR_4510_2,7,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									//超时时间（秒）
									p8=(u8*)ADDR_STRINGBUFF+(Ln+4)*84+4+10*2;
									i=p8_bcd(p8,3);
									i<<=2;
									//重发次数
									p8=(u8*)ADDR_STRINGBUFF+(Ln+5)*84+4+10*2;
									k=p8_bcd(p8,1);
									i|=k;
									MWR(i,x+2,1);
								}
								//6.心跳周期(秒)  long-unsigned
								x=Get_ElementADDR(ADDR_4510_2,8,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
								if(x)
								{
									p8=(u8*)ADDR_STRINGBUFF+(Ln+6)*84+4+10*2;
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 4://超时时间
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,3);
								if(x>63)
								{
									bcd_p8(p8,0,3);
								}
								break;
							case 5://重发次数
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,1);
								if(x>3)
								{
									bcd_p8(p8,0,1);
								}
								break;
							case 6://6.心跳周期(秒)
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+10*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_2
// Descriptions:        侦听端口设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_2(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 x;
	u32 i;
	u32 j;
	u32 k;
	u32 Ln;	
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5_2);//显示菜单
			p8=Get_Element((u8*)ADDR_4510_2,4,0,LENmax_4510_2);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{
				if(p8[1])
				{//数组个数不为0，显示第1个侦听端口
					i=p8[3];
					i<<=8;
					i|=p8[4];
					p=(u8*)ADDR_STRINGBUFF+(Ln+1)*84+4+9*2;
					bcd_p8(p,i,5);					
				}
			}
			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=9;
			MenuCount->v2=13;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{	
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=2)
					{
						DisplayString(Ln+2,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{					
						case 1://侦听端口
							MenuCount->v1=9;
							MenuCount->v2=13;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2://确认设置
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;						
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://侦听端口  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}							
					}						
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://侦听端口  long-unsigned
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;
							default:
								break;
						}
					}						
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 2:
								DisplayClrRow_4(Ln+2);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+2,9,0,"OK");
								//保存设置的数据
							  //侦听端口
								x=Get_ElementADDR(ADDR_4510_2,4,1,LENmax_4510_2);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+9*2);
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);
								}							
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}										
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+9*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}
								break;
							default:
								break;
						}	
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0						
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;			
	}		
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_3
// Descriptions:        主站通信参数设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_3(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 x;
	u32 Ln;
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5_3);//显示菜单
			//IP
			p8=Get_Element((u8*)ADDR_4510_3,1,1,LENmax_4510_3);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{//IP
				p=(u8*)ADDR_STRINGBUFF+(Ln+1)*84+4+3*2;
				for(i=0;i<=3;i++)
				{
					bcd_p8(p+i*8,p8[i+2],3);
				}
				for(i=0;i<=2;i++)
				{
					p[3*2+i*8]='.';
					p[3*2+i*8+1]=0x20;
				}
			}
			//端口
			p8=Get_Element((u8*)ADDR_4510_3,1,2,LENmax_4510_3);//计算元素地址,使用ADDR_128K_DATABUFF
			if(p8)
			{//端口
				p=(u8*)ADDR_STRINGBUFF+(Ln+2)*84+4+5*2;
				i=p8[1];
				i<<=8;
				i|=p8[2];
				bcd_p8(p,i,5);
			}				
			MenuCount->v1=3;
			MenuCount->v2=19;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);		
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=3)
					{
						DisplayString(Ln+3,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{	
						case 1://IP
							MenuCount->v1=3;
							MenuCount->v2=19;
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}						
							break;
						case 2://端口
							MenuCount->v1=5;
							MenuCount->v2=9;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;						
					}						
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP 按右键不加
								break;	
							case 2://端口
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x<65535)
								{
									p8_add1(p8,5);
								}
								else
								{
									bcd_p8(p8,0,5);
								}
								break;	
							default:
								break;						
						}							
					}						
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP 按左键不减
								break;	
							case 2://端口
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x>0)
								{
									p8_sub1(p8,5);
								}
								else
								{
									bcd_p8(p8,65535,5);
								}
								break;					
							default:
								break;											
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1://IP
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								break;
							case 2://端口
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								break;
							case 3:
								DisplayClrRow_4(Ln+3);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+3,9,0,"OK");
								//保存设置的数据
								x=Get_ElementADDR(ADDR_4510_3,1,1,LENmax_4510_3);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)ADDR_DATABUFF;
									p=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+3*2);
									for(i=0;i<=3;i++)
									{
										p8[i]=p8_bcd(p+8*i,3);
									}
									MW(ADDR_DATABUFF,x+2,4);//写IP
								}	
								x=Get_ElementADDR(ADDR_4510_3,1,2,LENmax_4510_3);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
								if(x)
								{
									p8=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
									i=p8_bcd(p8,5);
									k=(i&0xff);
									k<<=8;
									k|=(i>>8);
									MWR(k,x+1,2);//写端口	
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+3*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								x=p8_bcd(p8+12*2,3);
								if(x>255)
								{
									bcd_p8(p8+12*2,0,3);
								}
								break;
							case 2:
								p16=(u16 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+16*2);
								p16[0]=0x2020;
								p16[1]=0x2020;
								p16[2]=32;//'左右箭头'
								p16[3]=33;
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								x=p8_bcd(p8,5);
								if(x>65535)
								{
									bcd_p8(p8,0,5);
								}							
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}				
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_4
// Descriptions:        终端IP设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_4(void)
{
	u8 *p;
	u8 *p8;
	u8 *p8d;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 x;
	u32 Row=1;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif
	Row+=Ln;

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6_4);//显示菜单
			//显示内存中数据
			//1.获取类型
			p8=Get_Element((u8*)ADDR_4510_4,1,0,LENmax_4510_4);//计算元素地址,使用ADDR_128K_DATABUFF
		  if(p8)
			{
				i=p8[1];//IP类型
				DisplayString(Ln+1,5,0,(u8 *)IpTypeList[(i&0x03)]);
			}	
			if(i==1)
			{//1=静态
				MR(ADDR_DATABUFF,ADDR_4510_4+6,4);//读终端IP
				MR(ADDR_DATABUFF+4,ADDR_4510_4+12,4);//读子网掩码
				MR(ADDR_DATABUFF+4+4,ADDR_4510_4+18,4);//读网关
			}
			else
			{//0=DHCP,2=PPPoE
				MC(0,ADDR_DATABUFF,12);//读终端IP、子网掩码、网关
			}
			p8=(u8 *)ADDR_DATABUFF;
			//2.终端IP
			p=(u8*)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
			for(i=0;i<=3;i++)
			{
				bcd_p8(p+i*8,p8[i],3);
			}
			for(i=0;i<=2;i++)
			{
				p[3*2+i*8]='.';
				p[3*2+i*8+1]=0x20;
			}
			//3.子网掩码
			p=(u8*)(ADDR_STRINGBUFF+(Ln+3)*84+4+5*2);
			for(i=0;i<=3;i++)
			{
				bcd_p8(p+i*8,p8[4+i],3);
			}
			for(i=0;i<=2;i++)
			{
				p[3*2+i*8]='.';
				p[3*2+i*8+1]=0x20;
			}
			//4.网关
			p=(u8*)(ADDR_STRINGBUFF+(Ln+4)*84+4+5*2);
			for(i=0;i<=3;i++)
			{
				bcd_p8(p+i*8,p8[8+i],3);
			}
			for(i=0;i<=2;i++)
			{
				p[3*2+i*8]='.';
				p[3*2+i*8+1]=0x20;
			}

			ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
			MenuCount->v1=5;
			MenuCount->v2=8;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=5)
					{
						DisplayString(Ln+5,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=5;
							MenuCount->v2=9;
							ArrowLR(Ln+Stack->MenuStack[MenuCount->Count].EditRow,18);//在Row行、Ln列显示左右箭头，同时清掉其他行的左右箭头
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=5;
							MenuCount->v2=19;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3:
							MenuCount->v1=5;
							MenuCount->v2=19;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 4:
							MenuCount->v1=5;
							MenuCount->v2=19;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 5:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x08)!=0)
					{//右键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8d=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								p8=(u8 *)ADDR_DATABUFF;
								switch(p8d[0])
								{
									case 0x44://DHCP
										i=1;
										MR(ADDR_DATABUFF,ADDR_4510_4+6,4);//读终端IP
										MR(ADDR_DATABUFF+4,ADDR_4510_4+12,4);//读子网掩码
										MR(ADDR_DATABUFF+4+4,ADDR_4510_4+18,4);//读网关
										break;
									case 0x06://静态
										i=2;
										MC(0,ADDR_DATABUFF,12);//读终端IP、子网掩码、网关
										break;
									case 0x50://PPPoE
										i=0;
										MC(0,ADDR_DATABUFF,12);//读终端IP、子网掩码、网关
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,5,0,(u8 *)IpTypeList[i]);
								//终端IP
								p=(u8*)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								//子网掩码
								p=(u8*)(ADDR_STRINGBUFF+(Ln+3)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[4+i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								//网关
								p=(u8*)(ADDR_STRINGBUFF+(Ln+4)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[8+i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x04)!=0)
					{//左键
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8d=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								p8=(u8 *)ADDR_DATABUFF;
								switch(p8d[0])
								{
									case 0x44://DHCP
										i=2;
										MC(0,ADDR_DATABUFF,12);//读终端IP、子网掩码、网关
										break;
									case 0x06://静态
										i=0;
										MC(0,ADDR_DATABUFF,12);//读终端IP、子网掩码、网关
										break;
									case 0x50://PPPoE
										i=1;
										MR(ADDR_DATABUFF,ADDR_4510_4+6,4);//读终端IP
										MR(ADDR_DATABUFF+4,ADDR_4510_4+12,4);//读子网掩码
										MR(ADDR_DATABUFF+4+4,ADDR_4510_4+18,4);//读网关
										break;
								}
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,5,0,(u8 *)IpTypeList[i]);
								//终端IP
								p=(u8*)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								//子网掩码
								p=(u8*)(ADDR_STRINGBUFF+(Ln+3)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[4+i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								//网关
								p=(u8*)(ADDR_STRINGBUFF+(Ln+4)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									bcd_p8(p+i*8,p8[8+i],3);
								}
								for(i=0;i<=2;i++)
								{
									p[3*2+i*8]='.';
									p[3*2+i*8+1]=0x20;
								}
								break;
							default:
								break;
						}
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
//								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(MenuCount->v1)*2);
//								//判断内存数据有错 则初始化1=静态
//								if(p8[0]==0x24)
//								{//错误IP类型
//									DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v1,0,(u8 *)IpTypeList[1]);
//								}
								break;
							case 2:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								if(p8[0]==0x06)
								{//固定IP可以设置 自动不能
									Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								}
								break;
							case 3:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								if(p8[0]==0x06)
								{//固定IP可以设置 自动不能
									Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								}
								break;
							case 4:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								if(p8[0]==0x06)
								{//固定IP可以设置 自动不能
									Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								}
								break;
							case 5:
								DisplayClrRow_4(Ln+5);//清屏幕显示的指定行(4个控制字不清)
								DisplayString(Ln+5,9,0,"OK");
								//保存设置的数据
							  //1.IP类型
								p8=(u8 *)ADDR_DATABUFF;
								p=(u8 *)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								if(p[0]==0x44)
								{//DHCP
									p8[0]=0x00;
								}
								if(p[0]==0x06)
								{//静态
									p8[0]=0x01;
								}
								if(p[0]==0x50)
								{//PPPoE
									p8[0]=0x02;
								}
								MW(ADDR_DATABUFF,ADDR_4510_4+3,1);//写IP类型
								//2.IP
								p=(u8 *)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									p8[1+i]=p8_bcd(p+8*i,3);
								}
								//3.子网掩码
								p=(u8 *)(ADDR_STRINGBUFF+(Ln+3)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									p8[5+i]=p8_bcd(p+8*i,3);
								}
								//4.网关
								p=(u8 *)(ADDR_STRINGBUFF+(Ln+4)*84+4+5*2);
								for(i=0;i<=3;i++)
								{
									p8[9+i]=p8_bcd(p+8*i,3);
								}
								if(p8[0]==1)
								{//静态
									MW(ADDR_DATABUFF+1,ADDR_4510_4+6,4);//写终端IP
									MW(ADDR_DATABUFF+1+4,ADDR_4510_4+12,4);//写子网掩码
									MW(ADDR_DATABUFF+1+4+4,ADDR_4510_4+18,4);//写网关									
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 2:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								x=p8_bcd(p8+12*2,3);
								if(x>255)
								{
									bcd_p8(p8+12*2,0,3);
								}
								break;
							case 3:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								x=p8_bcd(p8+12*2,3);
								if(x>255)
								{
									bcd_p8(p8+12*2,0,3);
								}
								break;
							case 4:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+5*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								x=p8_bcd(p8+12*2,3);
								if(x>255)
								{
									bcd_p8(p8+12*2,0,3);
								}
								break;
							default:
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}	
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_5
// Descriptions:         PPPoE用户名设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_5(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 x;
	u32 MinLn=4;//软键盘最小行号
	u32 MaxLn=8;//软键盘最大行号
	u32 LastLnMaxCol=14;//软键盘的最后一行最大列号
	u32 MinCol=0;//软键盘最小列号
	u32 MaxCol=19;//软键盘最大列号
	u32 EditCol=0;
	u32 EditLength=20;
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	u8 * p8d;
#endif

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0：初始化
			Stack->MenuStack[MenuCount->Count].Task=2;
			p8=" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~`!@#$%^&*()_+-={}[]|:;'\",.?/\\<>";
			DisplayClr();//清全屏
			DisplayString(MinLn,MinCol,0,p8);
			switch(Stack->MenuStack[MenuCount->Count-1].EditRow+Stack->MenuStack[MenuCount->Count-1].MoveRow)
			{
				case 5:
					DisplayString(0,3,0,"PPPoE用户名设置");
					p=Get_Element((u8*)ADDR_4510_4,5,0,LENmax_4510_4);//计算元素地址,使用ADDR_128K_DATABUFF
					if(p)
					{
						i=p[1];//用户名长度
						p+=2;
						if(i>32)
						{//暂固定用户名长度32字节
							i=32;
						}
						MC(0,ADDR_DATABUFF+32,1);
						MR(ADDR_DATABUFF,(u32)p,32);						
					}
					p8=(u8 *)ADDR_DATABUFF;
					DisplayString(MenuCount->v1,EditCol,0,p8);
				break;
				case 6:
					DisplayString(0,4,0,"PPPoE密码设置");
					p=Get_Element((u8*)ADDR_4510_4,6,0,LENmax_4510_4);//计算元素地址,使用ADDR_128K_DATABUFF
					if(p)
					{
						i=p[1];//用户名长度
						p+=2;
						if(i>32)
						{//暂固定用户名长度32字节
							i=32;
						}
						MC(0,ADDR_DATABUFF+32,1);
						MR(ADDR_DATABUFF,(u32)p,32);						
					}
					p8=(u8 *)ADDR_DATABUFF;
					DisplayString(MenuCount->v1,EditCol,0,p8);
					break;
			}			
			Comm_Ram->DisplayScanTimer=0;//2 显示扫描10Ms定时器
			NegativeLnCol(MenuCount->v1,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
			break;
		case 1://任务1：键盘选择
			KeyboardSelect(MinLn,MaxLn,LastLnMaxCol,MinCol,MaxCol,MenuCount->v1,EditCol);//键盘选择
			break;
		case 2://任务2：编辑框选择
			if((Comm_Ram->ButtonVal&0x01)!=0)
			{//下键
				Stack->MenuStack[MenuCount->Count].EditRow = 4;
				Stack->MenuStack[MenuCount->Count].EditCol = 0;
				p16=(u16 *)(ADDR_STRINGBUFF+(Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(Stack->MenuStack[MenuCount->Count].EditCol)*2);
				*p16|=0x8000;
				Stack->MenuStack[MenuCount->Count].Task = 1;
			}
			else
			{
				if((Comm_Ram->ButtonVal&0x08)!=0)
				{//右键
					switch(MenuCount->v1)
					{
						case 1:
							Stack->MenuStack[MenuCount->Count].MoveRow ++;
							if(Stack->MenuStack[MenuCount->Count].MoveRow == EditLength)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 0;
								(MenuCount->v1)++;
							}
							break;
						case 2:
							Stack->MenuStack[MenuCount->Count].MoveRow ++;
							if(Stack->MenuStack[MenuCount->Count].MoveRow == 12)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 0;
								(MenuCount->v1)--;
							}
							break;
					}
				}
				if((Comm_Ram->ButtonVal&0x04)!=0)
				{//左键
					switch(MenuCount->v1)
					{
						case 1:
							if(Stack->MenuStack[MenuCount->Count].MoveRow > 0)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow --;
							}
							else
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = 11;
								(MenuCount->v1)++;
							}
							break;
						case 2:
							if(Stack->MenuStack[MenuCount->Count].MoveRow > 0)
							{
								Stack->MenuStack[MenuCount->Count].MoveRow --;
							}
							else
							{
								Stack->MenuStack[MenuCount->Count].MoveRow = EditLength-1;
								(MenuCount->v1)--;
							}
							break;
					}
				}
				NegativeLnCol(MenuCount->v1,Stack->MenuStack[MenuCount->Count].MoveRow+EditCol);
				if((Comm_Ram->ButtonVal&0x10)!=0)
				{//确认
					//保存数据
					p8=(u8 *)ADDR_DATABUFF;
					MC(0,ADDR_DATABUFF+32,1);
					p=(u8 *)(ADDR_STRINGBUFF+1*84+4+(EditCol)*2);
					for(i=0;i<=19;i++)
					{
						if(p[i*2]==0x20 || p[i*2]==0x00)
						{
							p[i*2]=0x00;
						}
						p8[i]=p[i*2];
					}
					p=(u8 *)(ADDR_STRINGBUFF+2*84+4+0*2);
					for(i=0;i<=11;i++)
					{
						if(p[i*2]==0x20 || p[i*2]==0x00)
						{
							p[i*2]=0x00;
						}
						p8[20+i]=p[i*2];
					}
					for(i=0;i<=31;i++)
					{
						if(p8[i]==0x00)
						{
							break;
						}
					}
					if(i!=32)
					{
						for(j=i;j<=31;j++)
						{
							p8[j]=0x00;
						}
					}
					switch(Stack->MenuStack[MenuCount->Count-1].EditRow)
					{
						case 5:
							x=Get_ElementADDR(ADDR_4510_4,5,0,LENmax_4510_4);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
							if(x)
							{
								MW(ADDR_DATABUFF,x+2,32);
							}
							break;
						case 6:
							x=Get_ElementADDR(ADDR_4510_4,6,0,LENmax_4510_4);//计算元素地址(实际逻辑地址),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
							if(x)
							{
								MW(ADDR_DATABUFF,x+2,32);
							}
							break;
					}
					//设置成功提示OK
					DisplayClrRow(1,9);
					DisplayString(1,2,0,p8);
					DispalyAlign(1,0,2);//行显示对其(1左对齐,2居中,3右对齐)
					DispalyAlign(2,0,2);//行显示对其(1左对齐,2居中,3右对齐)
					DisplayString(4,7,0,"设置OK");
					DisplayString(5,4,0,"按任意键退出");
					Stack->MenuStack[MenuCount->Count].Task=3;
				}
				if((Comm_Ram->ButtonVal&0x20)!=0)
				{//返回
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
					p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用 0=否1=是
					p8d[0]=1;//菜单显示顶、底行用 0=否1=是
#endif
					Stack->MenuStack[MenuCount->Count].MoveRow =0;
					MenuDel();//返回上级菜单
				}
			}
			Comm_Ram->ButtonVal&=~0x3D;//键使用后清0
			break;
		case 3://设置成功按任意键退出
			if((Comm_Ram->ButtonVal&0x3F)!=0)
			{
#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
				p8d=(u8 *)ADDR_MenuICO;//菜单显示顶、底行用 0=否1=是
				p8d[0]=1;//菜单显示顶、底行用 0=否1=是
#endif
				Stack->MenuStack[MenuCount->Count].MoveRow =0;
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x3F;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_6_1
// Descriptions:        MAC地址设置(十进制)
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------

void Menu_2_6_6_1(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 x;
	u32 Row=1;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif
	Row+=Ln;

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6_6_1);//显示菜单
			//显示内存中数据
			//MAC			
			p8=(u8 *)ADDR_DATABUFF;
			p16=(u16 *)(ADDR_STRINGBUFF+Row*84+4+5*2);
			MR(ADDR_DATABUFF,ADDR_4510_5+2,6);//读MAC
			Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
			for(i=0;i<3;i++)
			{
				p16 = DisplayData(hex_bcd(p8[i]),3,0,p16);
				p16[0] = 0x2000+'-';
				p16++;
			}
			p16--;
			p16[0]=0x0;
			Row++;
			p16=(u16 *)(ADDR_STRINGBUFF+Row*84+4+5*2);
			for(i=0;i<3;i++)
			{
				p16 = DisplayData(hex_bcd(p8[3+i]),3,0,p16);
				p16[0] = 0x2000+'-';
				p16++;
			}
			p16--;
			p16[0]=0x0;			
			MenuCount->v1=5;
			MenuCount->v2=15;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=3)
					{
						DisplayClrRow_4(Ln+3);//清屏幕显示的指定行(4个控制字不清)
						DisplayString(Ln+3,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=5;
							MenuCount->v2=15;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=5;
							MenuCount->v2=15;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 3:
							MenuCount->v1=0;
							for(k=0;k<10;k++)
							{
								if(k!=(Ln+Stack->MenuStack[MenuCount->Count].EditRow))
								{
									p16=(u16 *)(ADDR_STRINGBUFF+k*84+4+16*2);
									if((p16[2]&0x7fff)==32 && (p16[3]&0x7fff)==33)
									{
										for(i=2;i<=3;i++)
										{
											p16[i]=(p16[i]&0x8000)+0x2020;
										}
									}
								}
							}
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(MenuCount->v1)*2);
								//判断内存数据有错 则初始化
								for(i=0;i<3;i++)
								{
									for(k=4*i;k<=4*i+2;k++)
									{
										if(p8[k*2]<0x30 || p8[k*2]>0x39 ||p8[k*2+1]!=0x20)
										{
											break;
										}
									}
									if(k!=4*i+3)
									{
										break;
									}
								}
								if(i!=3)
								{
									for(i=0;i<3;i++)
									{
										for(k=4*i;k<=4*i+2;k++)
										{
											p8[k*2]=0x30;
										}
									}
								}
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								break;
							case 2:
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								DisplayString(Ln+Stack->MenuStack[MenuCount->Count].EditRow,16,0,"输入");
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(MenuCount->v1)*2);
								//判断内存数据有错 则初始化
								for(i=0;i<3;i++)
								{
									for(k=4*i;k<=4*i+2;k++)
									{
										if(p8[k*2]<0x30 || p8[k*2]>0x39 ||p8[k*2+1]!=0x20)
										{
											break;
										}
									}
									if(k!=4*i+3)
									{
										break;
									}
								}
								if(i!=3)
								{
									for(i=0;i<3;i++)
									{
										for(k=4*i;k<=4*i+2;k++)
										{
											p8[k*2]=0x30;
										}
									}
								}
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								break;
							case 3:
								//保存设置的数据
								Row=1;
								Row+=Ln;
								MR(ADDR_DATABUFF,ADDR_4510_5+2,6);//读MAC
								p8=(u8 *)ADDR_DATABUFF;
								p=(u8 *)(ADDR_STRINGBUFF+Row*84+4+5*2);
								for(i=0;i<3;i++)
								{
									p8[i]=p8_bcd(p+8*i,3);
								}
								Row++;
								p=(u8 *)(ADDR_STRINGBUFF+Row*84+4+5*2);
								for(i=0;i<3;i++)
								{
									p8[3+i]=p8_bcd(p+8*i,3);
								}
								Row++;
								DisplayClrRow_4(Row);//清屏幕显示的指定行(4个控制字不清)
								if(IC_24AAxxx==0 && (p8[0]&0x01)==0)
								{
									Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
									MW(ADDR_DATABUFF,ADDR_4510_5+2,6);//写MAC
									DisplayString(Row,9,0,"OK");
								}
								else
								{
									if(IC_24AAxxx)
									{//IC_24AAxxx为0表示可设置；1表示已有唯一MAC，故不可设置
										DisplayString(Row,2,0,"MAC唯一无需设置");
									}
									else
									{//(p8[0]&0x01)==1 组播地址
										DisplayString(Row,1,0,"首字节为奇数不允许");
									}
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x13;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x03;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					Select(MenuCount->v2,MenuCount->v1);
					UpDownSelect();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+5*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								for(i=0;i<8;i++)
								{
									p8[11*2+i]=0x0;
								}
								if((p8[2*2]-0x30)&0x01)
								{//0单播地址 1组播地址 MAC地址为单播地址 首字节末位便是单播/组播地址
									p8[2*2]=p8[2*2]-1;
								}
								break;
							case 2:
								p8=(u8*)(ADDR_STRINGBUFF+(Ln+2)*84+4+5*2);
								x=p8_bcd(p8,3);
								if(x>255)
								{
									bcd_p8(p8,0,3);
								}
								x=p8_bcd(p8+4*2,3);
								if(x>255)
								{
									bcd_p8(p8+4*2,0,3);
								}
								x=p8_bcd(p8+8*2,3);
								if(x>255)
								{
									bcd_p8(p8+8*2,0,3);
								}
								for(i=0;i<8;i++)
								{
									p8[11*2+i]=0x0;
								}
								break;
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}
//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_6_2
// Descriptions:        MAC地址设置（十六进制）
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------

void Menu_2_6_6_2(void)
{
	u8 *p;
	u8 *p8;
	u16 *p16;
	u32 i;
	u32 j;
	u32 k;
	u32 Row=1;
	u32 Ln;

#if (((Project/100)==3&&(USER/100)==5) || ((USER/100)==13) || ((USER/100)==11))//上海专变、黑龙江、吉林
	Ln=1;//菜单从第1行开始
#else
	Ln=0;//菜单从第0行开始
#endif
	Row+=Ln;

	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6_6_2);//显示菜单
			//显示内存中数据
			//MAC			
			p8=(u8 *)ADDR_DATABUFF;
			p16=(u16 *)(ADDR_STRINGBUFF+Row*84+4+3*2);
			MR(ADDR_DATABUFF,ADDR_4510_5+2,6);//读MAC
			Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
			for(i=0;i<6;i++)
			{
				p16 = DisplayData(p8[i],2,0,p16);
				p16[0] = 0x2000+'-';
				p16++;
			}
			p16--;
			p16[0]=0x0;
			MenuCount->v1=3;
			MenuCount->v2=19;
			NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
			break;
		case 1://任务1:选择
			for(j=0;j<2;j++)
			{
				if(Stack->MenuStack[MenuCount->Count].EditCol==0)
				{
					BoxSelect();
					if(Stack->MenuStack[MenuCount->Count].EditRow!=2)
					{
						DisplayClrRow_4(Ln+2);//清屏幕显示的指定行(4个控制字不清)
						DisplayString(Ln+2,6,0,"确认设置");
					}
					switch(Stack->MenuStack[MenuCount->Count].EditRow)
					{
						case 1:
							MenuCount->v1=3;
							MenuCount->v2=19;
							NegativeLnMaxColMinCol(Stack->MenuStack[MenuCount->Count].EditRow,MenuCount->v2,MenuCount->v1);
							break;
						case 2:
							MenuCount->v1=0;
							MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);
							break;
						default:
							break;
					}
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						switch(Stack->MenuStack[MenuCount->Count].EditRow)
						{
							case 1:
								p8=(u8 *)(ADDR_STRINGBUFF+(Ln+Stack->MenuStack[MenuCount->Count].EditRow)*84+4+(MenuCount->v1)*2);
								//判断内存数据有错 则初始化
								for(i=0;i<=5;i++)
								{
									for(k=3*i;k<=3*i+1;k++)
									{
										if(p8[k*2]<0x30 || (p8[k*2]>0x39 && p8[k*2]<0x41) || p8[k*2]>0x46 ||p8[k*2+1]!=0x20)
										{
											break;
										}
									}
									if(k!=3*i+2)
									{
										break;
									}
								}
								if(i!=6)
								{
									for(i=0;i<=5;i++)
									{
										for(k=3*i;k<=3*i+1;k++)
										{
											p8[k*2]=0x30;
										}
									}
								}
								Stack->MenuStack[MenuCount->Count].EditCol=MenuCount->v1;
								break;
							case 2:
								//保存设置的数据
								Row=1;
								Row+=Ln;
								MR(ADDR_DATABUFF,ADDR_4510_5+2,6);//读MAC
								p=(u8 *)(ADDR_STRINGBUFF+Row*84+4+3*2);
								p8=(u8 *)ADDR_DATABUFF;
								for(i=0;i<=5;i++)
								{
									if((p[(0+3*i)*2]>=0x30) && (p[(0+3*i)*2]<=0x39))
									{
										if((p[(1+3*i)*2]>=0x30) && (p[(1+3*i)*2]<=0x39))
										{
											p8[i]=(p[(0+3*i)*2]-0x30)*16+(p[(1+3*i)*2]-0x30)*1;
										}
										if((p[(1+3*i)*2]>=0x41) && (p[(1+3*i)*2]<=0x46))
										{
											p8[i]=(p[(0+3*i)*2]-0x30)*16+(p[(1+3*i)*2]-0x37)*1;
										}
									}
									if((p[(0+3*i)*2]>=0x41) && (p[(0+3*i)*2]<=0x46))
									{
										if((p[(1+3*i)*2]>=0x30) && (p[(1+3*i)*2]<=0x39))
										{
											p8[i]=(p[(0+3*i)*2]-0x37)*16+(p[(1+3*i)*2]-0x30)*1;
										}
										if((p[(1+3*i)*2]>=0x41) && (p[(1+3*i)*2]<=0x46))
										{
											p8[i]=(p[(0+3*i)*2]-0x37)*16+(p[(1+3*i)*2]-0x37)*1;
										}
									}
								}
								Row++;
								DisplayClrRow_4(Row);//清屏幕显示的指定行(4个控制字不清)
								if(IC_24AAxxx==0 && (p8[0]&0x01)==0)
								{
									Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
									MW(ADDR_DATABUFF,ADDR_4510_5+2,6);//写MAC
									DisplayString(Row,9,0,"OK");
								}
								else
								{
									if(IC_24AAxxx)
									{//IC_24AAxxx为0表示可设置；1表示已有唯一MAC，故不可设置
										DisplayString(Row,6,0,"MAC 唯一");
									}
									else
									{//(p8[0]&0x01)==1 组播地址
										DisplayString(Row,4,0,"首字节为奇数");
									}
								}
								break;
							default:
								break;
						}
						Comm_Ram->ButtonVal&=~0x13;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x03;//键使用后清0
						break;
					}
				}
				else//if(Stack->MenuStack[MenuCount->Count].EditCol!=0)
				{
					SelectH(MenuCount->v2,MenuCount->v1);
					UpDownSelectH();
					if((Comm_Ram->ButtonVal&0x10)!=0)
					{//确认
						p8=(u8*)(ADDR_STRINGBUFF+(Ln+1)*84+4+3*2);
						if(p8[1*2]>=0x30 && p8[1*2]<=0x39)
						{
							if((p8[1*2]-0x30)&0x01)
							{//0单播地址 1组播地址 MAC地址为单播地址 首字节末位表示单播/组播地址
								p8[1*2]=p8[1*2]-1;
							}
						}
						else if(p8[1*2]>=0x41 && p8[1*2]<=0x46)
						{
							if((p8[1*2]-0x37)&0x01)
							{//0单播地址 1组播地址 MAC地址为单播地址 首字节末位表示单播/组播地址
								p8[1*2]=p8[1*2]-1;
							}
						}
						Stack->MenuStack[MenuCount->Count].EditCol=0;
						Comm_Ram->ButtonVal&=~0x1F;//键使用后清0
					}
					else
					{
						Comm_Ram->ButtonVal&=~0x0F;//键使用后清0
						break;
					}
				}
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x20;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6_6
// Descriptions:         MAC地址设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6_6(void)
{
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6_6);//显示菜单
			Arrowhead();
			MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);//反显菜单行
			break;
		case 1://任务1:选择
			MenuSelect();//菜单选择
			if((Comm_Ram->ButtonVal&0x10)!=0)
			{//确认
				switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
				{
					case 1:
						MenuCreate((u32)Menu_2_6_6_1);//创建下级菜单   MAC地址设置(十进制)         
						break;
					case 2:
						MenuCreate((u32)Menu_2_6_6_2);//创建下级菜单   MAC地址设置(十六进制)
						break;
					default:
						break;
				}              
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x33;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_5
// Descriptions:        无线公网设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_5(void)
{
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_5);//显示菜单
			Arrowhead();
			MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);//反显菜单行
			break;
		case 1://任务1:选择
			MenuSelect();//菜单选择
			if((Comm_Ram->ButtonVal&0x10)!=0)
			{//确认
				switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
				{
					case 1:
						MenuCreate((u32)Menu_2_5_1);//通信模式设置           
						break;
					case 2:
						MenuCreate((u32)Menu_2_5_2);//侦听端口设置           
						break;
					case 3:
						MenuCreate((u32)Menu_2_5_3);//主站通信参数设置           
						break;
					case 4:
						MenuCreate((u32)Menu_2_5_4);//APN设置           
						break;
					case 5:
					case 6:
						MenuCount->v1=1;
						MenuCreate((u32)Menu_2_5_5);//5、6用户名设置 、密码设置
						break;
					default:
						break;
				}              
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x33;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2_6
// Descriptions:        以太网设置
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2_6(void)
{
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2_6);//显示菜单
			Arrowhead();
			MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);//反显菜单行
			break;
		case 1://任务1:选择
			MenuSelect();//菜单选择
			if((Comm_Ram->ButtonVal&0x10)!=0)
			{//确认
				switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
				{
					case 1:
						MenuCreate((u32)Menu_2_6_1);//1.通信配置           
						break;
					case 2:
						MenuCreate((u32)Menu_2_6_2);//2.侦听端口设置           
						break;
					case 3:
						MenuCreate((u32)Menu_2_6_3);//3.主站通信参数设置           
						break;
					case 4:
						MenuCreate((u32)Menu_2_6_4);//4.终端IP设置           
						break;
					case 5:
					case 6:
						MenuCount->v1=1;
						MenuCreate((u32)Menu_2_6_5);//5、6 PPPoE用户名、密码设置           
						break;
					case 7:
						MenuCreate((u32)Menu_2_6_6);//7. MAC地址设置           
						break;
					default:
						break;
				}              
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x33;//键使用后清0
			break;
		default:
			break;
	}
}

//-------------------------------------------------------------------------------------------------
// Function name:       Menu_2
// Descriptions:        集中器参数设置与查看
// input parameters:    无
// output parameters:   无
// Returned value:      无
//-------------------------------------------------------------------------------------------------
void Menu_2(void)//集中器参数设置与查看
{
	switch(Stack->MenuStack[MenuCount->Count].Task)//菜单任务计数
	{
		case 0://任务0:初始化
			Stack->MenuStack[MenuCount->Count].Task=1;
			DisplayMenu(Stack->MenuStack[MenuCount->Count].MoveRow,(u8 *)pMenu_2);//显示菜单
			Arrowhead();
			MenuNegative(Stack->MenuStack[MenuCount->Count].EditRow);//反显菜单行
			break;
		case 1://任务1:选择
			MenuSelect();//菜单选择
			if((Comm_Ram->ButtonVal&0x10)!=0)
			{//确认
				switch(Stack->MenuStack[MenuCount->Count].EditRow+Stack->MenuStack[MenuCount->Count].MoveRow)
				{
					case 1:
						MenuCreate((u32)Menu_2_1);//电能表参数设置       
						break;
					case 2:
						MenuCreate((u32)Menu_2_2);//集中器时间设置
						break;
					case 3:
						MenuCreate((u32)Menu_2_3);//集中器地址设置
						break;
					case 4:
//						MenuCreate((u32)Menu_2_4);//界面密码设置
						break;
					case 5:
						MenuCreate((u32)Menu_2_5);//无线公网设置
						break;
					case 6:
						MenuCreate((u32)Menu_2_6);//以太网设置
						break;
					default:
						break;
				}              
			}
			if((Comm_Ram->ButtonVal&0x20)!=0)
			{//返回
				MenuDel();//返回上级菜单
			}
			Comm_Ram->ButtonVal&=~0x33;//键使用后清0
			break;
		default:
			break;
	}
}
