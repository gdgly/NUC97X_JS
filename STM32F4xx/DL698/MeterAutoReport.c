

#include "Project698.h"
#include "../DL698/DL698_DataDef.h"
#include "../DL698/MeterAutoReport.h"
#include "../DL698/MeterAutoReport_Record.h"
#include "../DL698/RM_Record.h"
#include "../DL698/EVENT_Record.h"
#include "../DL698/RM_TASK.h"
#include "../DL698/DL698_Uart.h"
#include "../DL698/RM_TxDATA.h"
#include "../DL698/RM_RxDATA.h"
#include "../DL698/RM_RS485.h"
#include "../DL698/Uart_3762_RxTx.h"

#include "../STM32F4xx/STM32F4xx_UART.h"
#include "../Calculate/Calculate.h"
#include "../Device/MEMRW.h"
#include "../STM32F4xx/STM32F4xx_SoftDelay.h"
#include "../Device/IC_TESAM.h"



/*
const MeterAutoReportLIB_typedef MeterAutoReportLIB[]=
{
//B0负荷开关误动或拒动
	0,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302B0200,//对应事件的OAD
	0x03360000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03360001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B1 ESAM错误
//B2 内卡初始化错误	
//B3 时钟电池电压低
//B4 内部程序错误
//B5 存储器故障或损坏
//B6 保留
//B7 时钟故障
//B8 停电抄表电池欠压
//B9 透支状态
//B10开表盖
	10,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301B0200,//对应事件的OAD
	0x03300D00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300D01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B11开端钮盖
	11,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301C0200,//对应事件的OAD
	0x03300E00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300E01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B12恒定磁场干扰	
	12,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302A0200,//对应事件的OAD
	0x03350000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03350001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B13电源异常
	13,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302C0200,//对应事件的OAD
	0x03370000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03370001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B14跳闸成功
	14,//对应DL645-2007主动上报状态字中的位B0-B95
	0x311F0200,//对应事件的OAD
	0x1D000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1D00FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B15合闸成功
	15,//对应DL645-2007主动上报状态字中的位B0-B95
	0x31200200,//对应事件的OAD
	0x1E000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1E00FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B16 A相失压
	16,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000700,//对应事件的OAD
	0x10010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1001FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B17 A相欠压
	17,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010700,//对应事件的OAD
	0x11010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1101FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B18 A相过压
	18,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020700,//对应事件的OAD
	0x12010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1201FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B19 A相失流
	19,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040700,//对应事件的OAD
	0x18010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1801FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B20 A相过流
	20,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050700,//对应事件的OAD
	0x19010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1901FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B21 A相过载
	21,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080700,//对应事件的OAD
	0x1C010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C01FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B22 A相功率反向
	22,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070700,//对应事件的OAD
	0x1B010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B01FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B23 A相断相
	23,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030700,//对应事件的OAD
	0x13010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1301FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B24 A相断流
	24,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060700,//对应事件的OAD
	0x1A010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A01FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
	
//B32 B相失压
	32,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000800,//对应事件的OAD
	0x10020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1002FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B33 B相欠压
	33,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010800,//对应事件的OAD
	0x11020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1102FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B34 B相过压
	34,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020800,//对应事件的OAD
	0x12020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1202FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B35 B相失流
	19,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040800,//对应事件的OAD
	0x18020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1802FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B36 B相过流
	36,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050800,//对应事件的OAD
	0x19020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1902FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B37 B相过载
	37,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080800,//对应事件的OAD
	0x1C020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C02FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B38 B相功率反向
	38,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070800,//对应事件的OAD
	0x1B020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B02FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B39 B相断相
	39,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030800,//对应事件的OAD
	0x13020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1302FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B40 B相断流
	40,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060800,//对应事件的OAD
	0x1A020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A02FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
	
//B48 C相失压
	48,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000900,//对应事件的OAD
	0x10030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1003FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B49 C相欠压
	49,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010900,//对应事件的OAD
	0x11030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1103FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B50 C相过压
	50,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020900,//对应事件的OAD
	0x12030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1203FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B51 C相失流
	51,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040900,//对应事件的OAD
	0x18030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1803FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B52 C相过流
	52,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050900,//对应事件的OAD
	0x19030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1903FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B53 C相过载
	53,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080900,//对应事件的OAD
	0x1C030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C03FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B54 C相功率反向
	54,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070900,//对应事件的OAD
	0x1B030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B03FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B55 C相断相
	55,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030900,//对应事件的OAD
	0x13030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1303FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B56 C相断流
	56,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060900,//对应事件的OAD
	0x1A030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A03FF01,//对应DL645-2007最近1次事件的抄读标识,0=空

//B64电压逆相序
	64,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300F0200,//对应事件的OAD
	0x14000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1400FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B65电流逆相序
	65,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30100200,//对应事件的OAD
	0x15000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1500FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B66电压不平衡
	66,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301D0200,//对应事件的OAD
	0x16000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1600FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B67电流不平衡
	67,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301E0200,//对应事件的OAD
	0x17000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1700FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B68辅助电源失电
	68,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300E0200,//对应事件的OAD
	0x03060000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03060001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B69掉电
	69,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30110200,//对应事件的OAD
	0x03110000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03110001,//对应DL645-2007最近1次事件的抄读标识,0=空
	
//B70电能表正向有功需量超限事件
	70,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30090200,//对应事件的OAD
	0x03120000,//对应DL645-2007事件发生次数的抄读标识,0=空
//3byte 正向有功需量超限总次数
//3byte 反向有功需量超限总次数
//3byte 第一象限无功需量超限总次数
//3byte 第二象限无功需量超限总次数
//3byte 第三象限无功需量超限总次数
//3byte 第四象限无功需量超限总次数
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03120101,//对应DL645-2007最近1次事件的抄读标识,0=空
//0x03120101
//0x03120201
//0x03120301
//0x03120401
//0x03120501
//0x03120601
//根据事件次数包括的内容判断
	
//B71总功率因数超下限
	71,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300C0200,//对应事件的OAD
	0x1F000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1F00FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B72电流严重不平衡
	72,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302D0200,//对应事件的OAD
	0x20000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x2000FF01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B73潮流反向(功率反向代)
	73,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070200,//对应事件的OAD
	0x21000000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x21000001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B74全失压
	74,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300D0200,//对应事件的OAD
	0x03050000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03050001,//对应DL645-2007最近1次事件的抄读标识,0=空

//B80编程
	80,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30120200,//对应事件的OAD
	0x03300000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B81电表清零
	81,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30130200,//对应事件的OAD
	0x03300100,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300101,//对应DL645-2007最近1次事件的抄读标识,0=空
//B82需量清零
	82,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30140200,//对应事件的OAD
	0x03300200,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300201,//对应DL645-2007最近1次事件的抄读标识,0=空
//B83事件清零
	83,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30150200,//对应事件的OAD
	0x03300300,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300301,//对应DL645-2007最近1次事件的抄读标识,0=空
//B84校时
	84,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30160200,//对应事件的OAD
	0x03300400,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300401,//对应DL645-2007最近1次事件的抄读标识,0=空
//B85时段表编程
	85,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30170200,//对应事件的OAD
	0x03300500,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300501,//对应DL645-2007最近1次事件的抄读标识,0=空
//B86时区表编程
	86,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30180200,//对应事件的OAD
	0x03300600,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300601,//对应DL645-2007最近1次事件的抄读标识,0=空
//B87周休日编程
	87,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30190200,//对应事件的OAD
	0x03300700,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300701,//对应DL645-2007最近1次事件的抄读标识,0=空
//B88节假日编程
	88,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30210200,//对应事件的OAD
	0x03300800,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300801,//对应DL645-2007最近1次事件的抄读标识,0=空
//B89有功组合方式编程
	89,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30220200,//对应事件的OAD
	0x03300900,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300901,//对应DL645-2007最近1次事件的抄读标识,0=空
//B90无功组合方式1编程
	90,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30230200,//对应事件的OAD
	0x03300A00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300A01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B91无功组合方式2编程
	91,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30230200,//对应事件的OAD
	0x03300B00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300B01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B92结算日编程
	92,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301A0200,//对应事件的OAD
	0x03300C00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300C01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B93费率参数表编程
	93,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30240200,//对应事件的OAD
	0x03300F00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300F01,//对应DL645-2007最近1次事件的抄读标识,0=空
//B94阶梯表编程
	94,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30250200,//对应事件的OAD
	0x03301000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03301001,//对应DL645-2007最近1次事件的抄读标识,0=空
//B95密钥更新
	95,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30260200,//对应事件的OAD
	0x03301200,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03301201,//对应DL645-2007最近1次事件的抄读标识,0=空
};
*/

__align(4) const MeterAutoReportLIB_typedef MeterAutoReportLIB[]=
{
//B0负荷开关误动或拒动
	0,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302B0200,//对应事件的OAD
	0x03360000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03360001,//对应DL645-2007最近1次事件的抄读标识1,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B1 ESAM错误
//B2 内卡初始化错误	
//B3 时钟电池电压低
//B4 内部程序错误
//B5 存储器故障或损坏
//B6 保留
//B7 时钟故障
//B8 停电抄表电池欠压
//B9 透支状态
	
//B10开表盖
	10,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301B0200,//对应事件的OAD
	0x03300D00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300D01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B11开端钮盖
	11,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301C0200,//对应事件的OAD
	0x03300E00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300E01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B12恒定磁场干扰	
	12,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302A0200,//对应事件的OAD
	0x03350000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03350001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B13电源异常
	13,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302C0200,//对应事件的OAD
	0x03370000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03370001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B14跳闸成功
	14,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301F0200,//对应事件的OAD
	0x1D000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1D000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B15合闸成功
	15,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30200200,//对应事件的OAD
	0x1E000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1E000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B16 A相失压
	16,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000700,//对应事件的OAD
	0x10010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x10010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x10012501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B17 A相欠压
	17,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010700,//对应事件的OAD
	0x11010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x11010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x11012501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B18 A相过压
	18,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020700,//对应事件的OAD
	0x12010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x12010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x12012501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B19 A相失流
	19,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040700,//对应事件的OAD
	0x18010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x18010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x18012101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B20 A相过流
	20,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050700,//对应事件的OAD
	0x19010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x19010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x19012101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B21 A相过载
	21,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080700,//对应事件的OAD
	0x1C010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1C011201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B22 A相功率反向
	22,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070700,//对应事件的OAD
	0x1B010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1B011201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B23 A相断相
	23,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030700,//对应事件的OAD
	0x13010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x13010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x13012501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B24 A相断流
	24,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060700,//对应事件的OAD
	0x1A010001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A010101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1A012101,//对应DL645-2007最近1次事件的抄读标识2,0=空
	
//B32 B相失压
	32,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000800,//对应事件的OAD
	0x10020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x10020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x10022501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B33 B相欠压
	33,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010800,//对应事件的OAD
	0x11020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x11020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x11022501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B34 B相过压
	34,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020800,//对应事件的OAD
	0x12020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x12020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x12022501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B35 B相失流
	35,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040800,//对应事件的OAD
	0x18020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x18020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x18022101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B36 B相过流
	36,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050800,//对应事件的OAD
	0x19020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x19020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x19022101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B37 B相过载
	37,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080800,//对应事件的OAD
	0x1C020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1C021201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B38 B相功率反向
	38,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070800,//对应事件的OAD
	0x1B020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1B021201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B39 B相断相
	39,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030800,//对应事件的OAD
	0x13020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x13020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x13022501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B40 B相断流
	40,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060800,//对应事件的OAD
	0x1A020001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A020101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1A022101,//对应DL645-2007最近1次事件的抄读标识2,0=空
	
//B48 C相失压
	48,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30000900,//对应事件的OAD
	0x10030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x10030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x10032501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B49 C相欠压
	49,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30010900,//对应事件的OAD
	0x11030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x11030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x11032501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B50 C相过压
	50,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30020900,//对应事件的OAD
	0x12030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x12030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x12032501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B51 C相失流
	51,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30040900,//对应事件的OAD
	0x18030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x18030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x18032101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B52 C相过流
	52,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30050900,//对应事件的OAD
	0x19030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x19030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x19032101,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B53 C相过载
	53,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30080900,//对应事件的OAD
	0x1C030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1C030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1C031201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B54 C相功率反向
	54,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070900,//对应事件的OAD
	0x1B030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1B030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1B031201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B55 C相断相
	55,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30030900,//对应事件的OAD
	0x13030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x13030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x13032501,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B56 C相断流
	56,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30060900,//对应事件的OAD
	0x1A030001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1A030101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1A032101,//对应DL645-2007最近1次事件的抄读标识2,0=空
	
//B64电压逆相序
	64,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300F0200,//对应事件的OAD
	0x14000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x14000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x14001201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B65电流逆相序
	65,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30100200,//对应事件的OAD
	0x15000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x15000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x15001201,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B66电压不平衡
	66,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301D0200,//对应事件的OAD
	0x16000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x16000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x16001301,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B67电流不平衡
	67,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301E0200,//对应事件的OAD
	0x17000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x17000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x17001301,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B68辅助电源失电
	68,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300E0200,//对应事件的OAD
	0x03060000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03060001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B69掉电
	69,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30110200,//对应事件的OAD
	0x03110000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03110001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B70电能表正向有功需量超限事件
	70,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30090200,//对应事件的OAD,0x300a0200 0x3000b0600 0x3000b0700 0x3000b0800  0x3000b0900 
	0x03120000,//对应DL645-2007事件发生次数的抄读标识,0=空
//3byte 正向有功需量超限总次数
//3byte 反向有功需量超限总次数
//3byte 第一象限无功需量超限总次数
//3byte 第二象限无功需量超限总次数
//3byte 第三象限无功需量超限总次数
//3byte 第四象限无功需量超限总次数
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03120101,//对应DL645-2007最近1次事件的抄读标识,0=空
//0x03120101
//0x03120201
//0x03120301
//0x03120401
//0x03120501
//0x03120601
//根据事件次数包括的内容判断
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B71总功率因数超下限
	71,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300C0200,//对应事件的OAD
	0x1F000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x1F000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x1F000601,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B72电流严重不平衡
	72,//对应DL645-2007主动上报状态字中的位B0-B95
	0x302D0200,//对应事件的OAD
	0x20000001,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x20000101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0x20001301,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B73潮流反向(功率反向代)  ???有问题，功率反向是分 ABC相的 30070700 30070800 30070900
	73,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30070200,//对应事件的OAD
	0x21000000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x21000001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B74全失压
	74,//对应DL645-2007主动上报状态字中的位B0-B95
	0x300D0200,//对应事件的OAD
	0x03050000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03050001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
	
//B80编程
	80,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30120200,//对应事件的OAD
	0x03300000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B81电表清零
	81,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30130200,//对应事件的OAD
	0x03300100,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300101,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B82需量清零
	82,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30140200,//对应事件的OAD
	0x03300200,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300201,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B83事件清零
	83,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30150200,//对应事件的OAD
	0x03300300,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300301,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B84校时
	84,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30160200,//对应事件的OAD
	0x03300400,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300401,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B85时段表编程
	85,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30170200,//对应事件的OAD
	0x03300500,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300501,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B86时区表编程
	86,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30180200,//对应事件的OAD
	0x03300600,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300601,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B87周休日编程
	87,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30190200,//对应事件的OAD
	0x03300700,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300701,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B88节假日编程
	88,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30210200,//对应事件的OAD
	0x03300800,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300801,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B89有功组合方式编程
	89,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30220200,//对应事件的OAD
	0x03300900,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300901,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B90无功组合方式1编程
	90,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30230200,//对应事件的OAD
	0x03300A00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300A01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B91无功组合方式2编程
	91,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30230200,//对应事件的OAD
	0x03300B00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300B01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B92结算日编程
	92,//对应DL645-2007主动上报状态字中的位B0-B95
	0x301A0200,//对应事件的OAD
	0x03300C00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300C01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B93费率参数表编程
	93,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30240200,//对应事件的OAD
	0x03300F00,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03300F01,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B94阶梯表编程
	94,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30250200,//对应事件的OAD
	0x03301000,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03301001,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
//B95密钥更新
	95,//对应DL645-2007主动上报状态字中的位B0-B95
	0x30260200,//对应事件的OAD
	0x03301200,//对应DL645-2007事件发生次数的抄读标识,0=空
	0,//对应DL645-2007事件累计时间的抄读标识,0=空
	0x03301201,//对应DL645-2007最近1次事件的抄读标识,0=空
	0,//对应DL645-2007最近1次事件的抄读标识2,0=空
};


u32 MeterAutoReportStateWord(u32 PORTn,u8* p8rx)//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
{
	u32 i;
	UARTCtrl_TypeDef* UARTCtrl;
	u8* p8;
#if NUM_UART4RxCopyMax!=0
	u32 x;
	u32 y;
#endif
	
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	//if(p8rx[9]<=(4+12+2))
	if(p8rx[9]<(4+12+2))
	{//长度错或老格式(只有10字节状态字)
		return 1;//返回:0=没接受,1=接受
	}
	i=UARTCtrl->AutoReportTask;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
	if(i)
	{//当前UART正在处理主动上报
	#if NUM_UART4RxCopyMax==0
		return 0;//返回:0=没接受,1=接受
	#else
		//比较正在抄读的地址,如果相同丢弃
		for(i=0;i<6;i++)
		{
			if(p8rx[1+i]!=UARTCtrl->AutoReportRMAddr[i])
			{
				break;
			}
		}
		if(i>=6)
		{
			return 1;//返回:0=没接受,1=接受
		}
		//比较已经缓存的地址,如果相同替代
		x=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
		if(x>NUM_UART4RxCopyMax)
		{
			x=NUM_UART4RxCopyMax;
		}
		for(i=0;i<x;i++)
		{
			p8=(u8*)ADDR_UART4RxCopy+(i*LEN_UART4RxCopy);
			for(y=0;y<6;y++)
			{
				if(p8rx[1+y]!=p8[1+y])
				{
					break;
				}
			}
			if(y>=6)
			{//地址相同替代
				MW((u32)p8rx,ADDR_UART4RxCopy+(i*LEN_UART4RxCopy),LEN_UART4RxCopy);
				return 1;//返回:0=没接受,1=接受
			}
		}
		//主动上报接收帧缓存
		if(x>=NUM_UART4RxCopyMax)
		{
			return 1;//返回:0=没接受,1=接受
		}
		MW((u32)p8rx,ADDR_UART4RxCopy+(x*LEN_UART4RxCopy),LEN_UART4RxCopy);
		x++;
		UARTCtrl->AutoReportCopyNUM=x;//主动上报接收已经缓存帧数
		return 1;//返回:0=没接受,1=接受
	#endif
	}
	UARTCtrl->AutoReportTask=1;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
	i=p8rx[9];
	i+=12;
	if(i>sizeof(UARTCtrl->AutoReportData))
	{
		i=sizeof(UARTCtrl->AutoReportData);
	}
	MR((u32)&UARTCtrl->AutoReportData,(u32)p8rx,i);
	MR((u32)&UARTCtrl->AutoReportRMAddr,(u32)p8rx+1,6);//电能表主动上报地址
	//上报表的规约类型
	MR(ADDR_DATABUFF,(u32)p8rx+1,6);
	Data_Inverse(ADDR_DATABUFF,6);//数据倒序(高低字节调换),入口Le>=2
	i=AddrToMeterSetNo((u16*)ADDR_DATABUFF);//搜索通信地址在采集档案配置表中的序号;返回:从0开始的配置序号,>=NUM_RMmax表示无效
	if(i<NUM_RMmax)
	{//找到
		p8=(u8*)ADDR_6000_SDRAM+(i*LENper_6000);
		p8=Get_Element(p8,2,3,0);//计算元素地址(虚拟地址指针),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
		if(p8)
		{//找到
		#if NUM_RMmax<12
			#error
		#endif
			i=p8[1];
			if(i==3)
			{//698
				i=12;
			}
			else
			{//否则645
				i=0;
			}
		}
		else
		{
			i=NUM_RMmax;
		}
	}
	if(i>=NUM_RMmax)
	{//无效
		for(i=0;i<12;i++)
		{
			if(p8rx[14+i]!=0)
			{
				break;
			}
		}
	}
	if(i>=12)
	{//状态字内容全0,为698表模块自组DL/T645-2007协议帧
		UARTCtrl->AutoReportRMprotocol=3;//电能表主动上报规约=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
	}
	else
	{//645
		UARTCtrl->AutoReportRMprotocol=2;//电能表主动上报规约=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
	}
	return 1;//返回:0=没接受,1=接受
}


void DL645_MeterAutoReport_RxDataBuff(u32 PORTn,u8* p8rx)//DL645读到的电能表主动上报事件数据缓存
{
	u32 i;
	u32 n;
	u32 Len;
	u32 LEN_RxDataBuff;
	u8* p8Data;
	RecordFileHead_TypeDef* RecordFileHead;
	UARTCtrl_TypeDef* UARTCtrl;
	
//接收数据缓冲定义：
//typedef __packed struct
//{
//	u16 Addr0;
//	u16 Addr1;
//	u16 Addr2;
//	u16 LEN_DATA;
//}RecordFileHead_TypeDef;//抄表记录文件头
//0 4byte 数据来源端口号 OAD
//4 1byte 帧条数
//5  帧数据octet-string	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
	p8Data=(u8*)RecordFileHead+sizeof(RecordFileHead_TypeDef);
	Len=RecordFileHead->LEN_DATA;
	LEN_RxDataBuff=Get_LEN_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲长度
	LEN_RxDataBuff-=sizeof(RecordFileHead_TypeDef);
	if(LEN_RxDataBuff>2000)
	{
		LEN_RxDataBuff=2000;//为上报时每数据处理方便限长度
	}
	if(Len>LEN_RxDataBuff)
	{//长度错
		RecordFileHead->LEN_DATA=0;
		p8Data[4]=0;//帧条数
		return;
	}
	LEN_RxDataBuff-=Len;//剩余字节
	n=p8Data[4];//帧条数
	switch(UARTCtrl->AutoReportRMprotocol)//抄表规约类型=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
	{
		default:
			//return;
		case 1://DL/T645-1997（1）
		case 2://DL/T645-2007（2）
			i=p8rx[9];//当前帧长度
			i+=12;
			break;
		case 3://DL/T698.45（3）
			i=p8rx[1]+(p8rx[2]<<8);
			i+=2;
			break;
	}
	if(((i+4)>LEN_RxDataBuff)||(n>=255))
	{//缓冲不够,先存贮
		MeterAutoReport_Record(PORTn,(u8*)RecordFileHead,MeterAutoReportFileID_DL645);//DL645电能表主动上报记录文件;入口:pDATA=数据指针(分别为RecordFileHead+时标+帧个数和长度+数据)
		n=0;//帧条数
		Len=5;//帧数据总长度
	}
	p8Data[Len]=DataType_octet_string;
	if(i<=127)
	{
		p8Data[Len+1]=i;
		MR((u32)p8Data+Len+2,(u32)p8rx,i);
		Len+=2+i;
	}
	else
	{
		p8Data[Len+1]=0x82;
		p8Data[Len+2]=i>>8;
		p8Data[Len+3]=i;
		MR((u32)p8Data+Len+4,(u32)p8rx,i);
		Len+=4+i;
	}
	RecordFileHead->LEN_DATA=Len;//帧数据总长度
	n++;
	p8Data[4]=n;//帧条数
}

void MeterAutoReportStateWord_B0toB95(u32 PORTn)//主动上报状态字分解为B0-B95新增次数,若有没对应事件的发生位，状态字作为1条事件
{
	u32 i;
	u32 x;
	u32 y;
	u32 z;
	u32 f;
	u8 *p8;
	u8* p8rx;
	UARTCtrl_TypeDef* UARTCtrl;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	i=UARTCtrl->AutoReportData[9];
	i+=12;
	MR(ADDR_DATABUFF,(u32)&UARTCtrl->AutoReportData,i);
	p8rx=(u8*)ADDR_DATABUFF;
	//12byte 状态字寄存,用于发复位命令
	MR((u32)&UARTCtrl->AutoReportData,(u32)p8rx+14,12);
	//当前自动上报状态字转为按位相同偏移的新增次数存储
	p8=UARTCtrl->AutoReportData+12;
	for(i=0;i<96;i++)
	{
		p8[i]=0;
	}
	f=0;//没对应事件次数标志
	z=0;//己有置位计数
	for(i=0;i<12;i++)
	{
		for(x=0;x<8;x++)
		{
			y=p8rx[14+i];
			y&=(1<<x);
			if(y!=0)
			{//有新增次数
				y=p8rx[14+12+1+z];
				if(y>10)
				{
					y=10;//没发生次数的为0xff
				}
				if((((i*8)+x)>=1)&&(((i*8)+x)<=9))
				{//B1-B9没对应事件次数
					y=0;//没发生次数的为0xff
					f=1;//没对应事件标志
				}
				p8[(i*8)+x]=y;
				z++;//己有置位计数
			}
		}
	}
	//没对应事件次数写主动上报状态字作为事件
	if(f)
	{
		DL645_68H_Add33H_CS_16H(p8rx);//DL465帧起始符0x68,数据域加0x33,CS,结尾0x16
		DL645_MeterAutoReport_RxDataBuff(PORTn,p8rx);//DL645读到的电能表主动上报事件数据缓存
	}
}


void DL698_MeterAutoReport_RxDATA_START(u32 PORTn)//抄表接收数据处理-开始
{
	u8* p8;
	u16* p16;
  UARTCtrl_TypeDef * UARTCtrl;
	RecordFileHead_TypeDef* RecordFileHead;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲地址
	
	MR((u32)&RecordFileHead->Addr0,(u32)&UARTCtrl->RMAddr,6);//采集通信地址
	RecordFileHead->LEN_DATA=23;//长度=时标+已采集的CSD(不包括本身2字节)
	
	MR(((u32)RecordFileHead)+sizeof(RecordFileHead_TypeDef),ADDR_DL698YMDHMS,7);//采集启动时标(任务开始标准时间)  date_time_s(无数据类型)
//	DateSaveTI(PORTn,(u8*)((u32)RecordFileHead)+sizeof(RecordFileHead_TypeDef)+14);//采集存储时标
	p8=(u8*)RecordFileHead;
	p8[sizeof(RecordFileHead_TypeDef)+21]=DataType_array;//采集的CSD  array(有数据类型)
	p8[sizeof(RecordFileHead_TypeDef)+22]=0;
	
	p16=(u16*)RecordFileHead;
	p16[LEN_RM_DI_CSD/2]=0;//长度=已填写入buff但还没完整一个CSD的长度
	p16[(LEN_RM_DI_CSD/2)+1]=0;//长度=已填写入buff完整CSD的长度(不包括本身2字节)
	//p16[(LEN_RM_DI_CSD/2)+2]=DataType_array;//采集的数据(有数据类型)
}

void DL698_MeterAutoReport_RxDATA_END(u32 PORTn)//抄表接收数据处理-结束
{
	u32 len1;
	u32 len2;
	u16* p16;
	RecordFileHead_TypeDef* RecordFileHead;
	
	p16=(u16 *)Get_ADDR_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲地址
	RecordFileHead=(RecordFileHead_TypeDef*)p16;
	MR((u32)p16+sizeof(RecordFileHead_TypeDef)+7,ADDR_DL698YMDHMS,7);//采集成功时标  date_time_s(无数据类型)
	//DateSaveTI(PORTn,(u8*)((u32)RecordFileHead)+sizeof(RecordFileHead_TypeDef)+14);//采集存储时标
	MR((u32)p16+sizeof(RecordFileHead_TypeDef)+14,ADDR_DL698YMDHMS,7);//采集成功时标  date_time_s(无数据类型)
	//合并数据
	len1=RecordFileHead->LEN_DATA;
	len2=p16[(LEN_RM_DI_CSD/2)+1];
	RecordFileHead->LEN_DATA=len1+len2;
	MR(((u32)p16)+sizeof(RecordFileHead_TypeDef)+len1,((u32)p16)+LEN_RM_DI_CSD+4,len2);
}

u32 DL698_MeterAutoReport_RxDATA(u32 PORTn,u8* p8rx)//DL698读到的电能表主动上报事件数据缓存;返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
{
//UART抄表数据缓冲定义
//#define LEN_RM_DI_CSD     512
//抄表数据缓冲1,最大总长度=LEN_RM_DI_CSD
//0 6byte 电能表地址
//6 2byte 长度=时标+已采集的CSD(不包括本身2字节)

//8 7byte 采集启动时标  date_time_s(无数据类型)
//15 7byte 采集成功时标  date_time_s(无数据类型)
//22 7byte 采集存储时标  date_time_s(无数据类型)
//29  采集的CSD  array CSD(有数据类型)

//抄表数据缓冲2,最大总长度=LEN_UARTnFnDataBuff-LEN_RM_DI_CSD
//LEN_RM_DI_CSD   2byte 长度=已填写入buff但还没完整一个CSD的数据长度(不包括本身2字节)
//LEN_RM_DI_CSD+2 2byte 长度=已填写入buff完整CSD的数据长度(不包括本身2字节)
//LEN_RM_DI_CSD+4 采集的数据(有数据类型)(ROAD时不写入总关联的OAD个数数组!!!)
	
	u32 i;
	u32 x;
	u32 y;
	u32 OAD;
//	u32 ROAD;
	u32 NUM_RCSD;
	u32 OADrx;
	u32 NUM_RCSDrx;
	u8* p8;
	u32 LEN_RxDataBuff;
	u32 LEN_Data1;
	u8* p8Data;
	u16* p16Data;
	u32 fDATA;
	UARTCtrl_TypeDef * UARTCtrl;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	p8rx=(u8 *)Get_ADDR_UARTnRx(PORTn);
	LEN_RxDataBuff=Get_LEN_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲长度
	LEN_RxDataBuff-=(LEN_RM_DI_CSD+4);
	p8Data=(u8 *)Get_ADDR_UARTnFnDataBuff(PORTn);
	p16Data=(u16*)(p8Data+LEN_RM_DI_CSD);
	LEN_Data1=p16Data[1];
	if(LEN_RxDataBuff<LEN_Data1)
	{//错
		return 3;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
	}
	LEN_RxDataBuff-=LEN_Data1;
	p8Data+=LEN_RM_DI_CSD+4+LEN_Data1;
	
#if CompareMeterEventCount==1//全事件采集抄表是否比较发生次数:0=不比较(全部抄表数据写入文件),1=比较(只有次数变化的事件写入文件)
	i=Get_RxDATA_DL698_MeterEventCount(PORTn);//从698读事件记录接收帧中取出电能表事件发生次数(事件记录序号);返回:发生次数,没找到时返回0xffffffff
	if(i!=0xffffffff)
	{
		OAD=UARTCtrl->RMCSD[2+0]<<24;
		OAD|=UARTCtrl->RMCSD[2+1]<<16;
		OAD|=UARTCtrl->RMCSD[2+2]<<8;
		OAD|=UARTCtrl->RMCSD[2+3];
//		OAD=p8rx[17+0]<<24;
//		OAD|=p8rx[17+1]<<16;
//		OAD|=p8rx[17+2]<<8;
//		OAD|=p8rx[17+3];
		x=AddrToMeterSetNo((u16*)&UARTCtrl->RMAddr);//搜索通信地址在采集档案配置表中的序号;返回:从0开始的配置序号,>=NUM_RMmax表示无效
		i=CompSourMeterEventCount(x,OAD,i);//比较原电能表事件次数;入口:SetNo=档案配置号(0开始),Count=当前次数;返回:0=初始值,1=次数相同,2=次数不同,同时修改原计数,使用ADDR_DATABUFF
		if(i!=2)
		{
			//return 0;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
		}
	}
#endif
	fDATA=0;//有数据填入标志
	NUM_RCSD=UARTCtrl->RMCSD[6];
	NUM_RCSDrx=p8rx[21];//RCSD，SEQUENCE OF个数
	if(NUM_RCSD==0)
	{//当无一个OAD时，RCSD=0，即SEQUENCE OF的数据项个数为0，表示“不选择（即全选）”
		//为方便计算将接收的CSD复制作为发送选择的CSD
		x=NUM_RCSDrx*4;
		if((x+7)<sizeof(UARTCtrl->RMCSD))
		{
			UARTCtrl->RMCSD[6]=NUM_RCSDrx;
			for(y=0;y<NUM_RCSDrx;y++)
			{
				UARTCtrl->RMCSD[7+(4*y)]=p8rx[22+(y*5)+1];
			}
		}
	}
	p16Data[0]=0;
	for(x=0;x<NUM_RCSD;x++)
	{
		OAD=UARTCtrl->RMCSD[7+(4*x)]<<24;
		OAD|=UARTCtrl->RMCSD[8+(4*x)]<<16;
		OAD|=UARTCtrl->RMCSD[9+(4*x)]<<8;
		OAD|=UARTCtrl->RMCSD[10+(4*x)];
		for(y=0;y<NUM_RCSDrx;y++)
		{
			if(p8rx[22+(y*5)+0]==0)
			{
				OADrx=p8rx[22+(y*5)+1]<<24;
				OADrx|=p8rx[22+(y*5)+2]<<16;
				OADrx|=p8rx[22+(y*5)+3]<<8;
				OADrx|=p8rx[22+(y*5)+4];
				if(OAD==OADrx)
				{
					break;
				}
			}
		}
		if(y>=NUM_RCSDrx)
		{//没找到列选择OAD
			if(LEN_RxDataBuff<1)
			{//缓冲长度不够
				return 2;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
			}
			p8Data[0]=0;
			p8Data+=1;
			LEN_RxDataBuff-=1;
			p16Data[0]+=1;
		//#if (USER/100)==0//电科院互换性测试
			fDATA=1;//有数据填入标志
		//#endif
		}
		else
		{//找到列选择OAD
			p8=p8rx+22+(5*NUM_RCSDrx)+2;
			while(y--)
			{
				i=Get_DL698DataLen_S(p8,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
				p8+=i;
			}
			y=Get_DL698DataLen_S(p8,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
			if(y<=1)
			{//无数据
				if(LEN_RxDataBuff<1)
				{//缓冲长度不够
					return 2;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
				}
				p8Data[0]=0;
				p8Data+=1;
				LEN_RxDataBuff-=1;
				p16Data[0]+=1;
			//#if (USER/100)==0//电科院互换性测试
				fDATA=1;//有数据填入标志
			//#endif
				continue;
			}
			if(LEN_RxDataBuff<y)
			{//缓冲长度不够
				return 2;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
			}
			for(i=0;i<y;i++)
			{
				p8Data[i]=p8[i];
			}
			p8Data+=y;
			LEN_RxDataBuff-=y;
			p16Data[0]+=y;
			fDATA=1;//有数据填入标志
		}
	}
	//1个完整的CSD的数据
	if(fDATA)//有数据填入标志
	{
		UARTCtrl->RMCSDSubCountMax=0;//抄表CSD有子抄表个数(非DL698抄表规约库设定)
		UARTCtrl->RMROADCountMax=0;//要抄的CSD为OAD或ROAD不分多个OAD抄
		i=RM_One_CSD(PORTn);//检查抄表是否完成1个完整的CSD的数据;返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127
	}
	return 0;//返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127
}


u32 MeterAutoReport_TxDATA_DL2007(u32 PORTn,u8* p8tx)//DL645主动上报抄表发送帧;返回:组帧后总长度字节数
{
	u32 i;
	u32 bit;
	u32 x;
	u32 RMCSDCount;
	u32 RMCSDSubCount;
	UARTCtrl_TypeDef* UARTCtrl;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	RMCSDCount=UARTCtrl->RMCSDCount;
	RMCSDSubCount=UARTCtrl->RMCSDSubCount;
	while(1)
	{
		switch(RMCSDCount)
		{
			default:
				if(RMCSDCount>95)
				{//结束
					return 0;
				}
				if(RMCSDSubCount>(1+(2*10)))
				{
					RMCSDSubCount=0;
					RMCSDCount++;
					continue;
				}
				x=UARTCtrl->AutoReportData[12+RMCSDCount];
				if(x>10)
				{
					x=10;
				}
				if(x==0)
				{
					RMCSDSubCount=0;
					RMCSDCount++;
					continue;
				}
				for(bit=0;bit<(sizeof(MeterAutoReportLIB)/sizeof(MeterAutoReportLIB_typedef));bit++)
				{
					if(MeterAutoReportLIB[bit].BIT==RMCSDCount)
					{
						break;
					}
				}
				if(bit>=(sizeof(MeterAutoReportLIB)/sizeof(MeterAutoReportLIB_typedef)))
				{//没找到
					RMCSDSubCount=0;
					RMCSDCount++;
					continue;
				}
				if(RMCSDSubCount==0)
				{//读次数DI
					UARTCtrl->RM_DI=MeterAutoReportLIB[bit].DI_NUM;
				}
				else
				{//读事件DI
					x--;
					if((RMCSDSubCount&1)==1)
					{//必抄项DI1
						UARTCtrl->RM_DI=MeterAutoReportLIB[bit].DI_LASTEVENT1+x;
					}
					else
					{//必抄项DI2
						UARTCtrl->AutoReportData[12+RMCSDCount]=x;
						if(MeterAutoReportLIB[bit].DI_LASTEVENT2==0)
						{//无必抄项DI2;
							RMCSDSubCount++;
							continue;
						}
						UARTCtrl->RM_DI=MeterAutoReportLIB[bit].DI_LASTEVENT2+x;
					}
				}
				break;
			case 96://复位主动上报状态字
				if(RMCSDSubCount>=1)
				{
					RMCSDSubCount=0;
					RMCSDCount++;
					continue;
				}
				MR((u32)p8tx+1,(u32)&UARTCtrl->AutoReportRMAddr,6);
				p8tx[8]=0x14;
				p8tx[9]=24;
				MWR(0x04001503,(u32)p8tx+10,4);
				MC(0,(u32)p8tx+14,8);//密码,操作者代码
				MR(((u32)p8tx)+22,(u32)&UARTCtrl->AutoReportData,12);//复位主动上报状态字的位标志
				for(i=0;i<12;i++)
				{//取反标志位
					x=p8tx[22+i];
					x=~x;
					p8tx[22+i]=x;
				}
				DL645_68H_Add33H_CS_16H(p8tx);//DL465帧起始符0x68,数据域加0x33,CS,结尾0x16
				UARTCtrl->RMCSDCount=RMCSDCount;
				UARTCtrl->RMCSDSubCount=RMCSDSubCount;
				return 36;
			case 97://再次读主动上报状态字
			#if (USER%100)==0//电科院测试
				if(RMCSDSubCount>=1)
				{
					RMCSDSubCount=0;
					RMCSDCount++;
					continue;
				}
				UARTCtrl->RM_DI=0x04001501;
				break;
			#else
				//不是电科院测试，不再读因有些表复位主动上报状态字无效而进入读主动上报死M环
				return 0;
			#endif
		}
		break;
	}
	UARTCtrl->RMCSDCount=RMCSDCount;
	UARTCtrl->RMCSDSubCount=RMCSDSubCount;
	MR((u32)p8tx+1,(u32)&UARTCtrl->AutoReportRMAddr,6);
	p8tx[8]=0x11;
	p8tx[9]=4;
	x=UARTCtrl->RM_DI;
	MWR(x,(u32)p8tx+10,4);
	DL645_68H_Add33H_CS_16H(p8tx);//DL465帧起始符0x68,数据域加0x33,CS,结尾0x16
	return 16;
}

u32 MeterAutoReport_TxDATA_DL698(u32 PORTn,u8 *p8CSD,u8* p8tx)//DL698主动上报抄表发送帧;返回:组帧后总长度字节数
{
	u32 i;
	u32 x;
	u32 Byte;
	UARTCtrl_TypeDef* UARTCtrl;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	
//起始字符（68H）  1Byte
	p8tx[0]=0x68;
//长度域L  2Byte(除起始字符和结束字符之外的帧字节数)
//控制域C  1Byte
	p8tx[3]=0x43;
//地址域A
	p8tx[4]=5;
	p8tx[5]=UARTCtrl->RMAddr[2]>>8;
	p8tx[6]=UARTCtrl->RMAddr[2];
	p8tx[7]=UARTCtrl->RMAddr[1]>>8;
	p8tx[8]=UARTCtrl->RMAddr[1];
	p8tx[9]=UARTCtrl->RMAddr[0]>>8;
	p8tx[10]=UARTCtrl->RMAddr[0];
//客户机地址CA  1Byte
	p8tx[11]=0;
//帧头校验HCS  2Byte(帧头校验HCS为2字节，是对帧头部分除起始字符和HCS本身之外的所有字节的校验)
//空出3字节，当安全模式读取时用
	p8tx+=3;
//APDU
	p8tx[14]=5;//GET-Request
	p8tx[15]=1;//读取一个对象属性请求             [1] GetRequestNormal
	UARTCtrl->PIID++;
	p8tx[16]=UARTCtrl->PIID&0x3f;//PIID
	Byte=17;
	//OAD
	for(i=0;i<4;i++)
	{
		p8tx[Byte+i]=p8CSD[2+i];
	}
	Byte+=4;
//时间标签
	p8tx[Byte]=0;
	Byte+=1;
//安全模式读取
	p8tx-=3;//空出的3字节
	x=Byte-14;//APDU长度
	i=(p8CSD[2]<<8)|p8CSD[3];
	i=RM_SECURITY(i);//抄表安全模式字,入口:OI,出口:(同安全请求)b7=0无安全=1安全传输,b6=0明文=1密文,b5=,b4=,b3-b0=0数据验证码[0]SID_MAC =1随机数[1]RN =2随机数+数据MAC[2]RN_MAC =3安全标识[3]SID
	if(i==0)
	{//明文读取
		for(i=0;i<x;i++)
		{
			p8tx[14+i]=p8tx[17+i];
		}
	}
	else
	{//明文+数据验证码读取
	#if RM_SECURITY_MeterNo==0//0=否,1=是;DL698安全模式抄表时先抄读电能表表号(电能表表号用于计校验码)
		UARTCtrl->RM_Rx_date_40020200[0]=2;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
	#else
		if((((UARTCtrl->TaskID>>20)&0xf)==5)&&(Terminal_Router->MinuteCollect==1))
			UARTCtrl->RM_Rx_date_40020200[0]=2;
	#endif
		if(UARTCtrl->RM_Rx_date_40020200[0]!=2)//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
		{//先用明文读电能表表号
			UARTCtrl->RM_Rx_date_40020200[0]=1;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
			p8tx[14]=5;//GET-Request
			p8tx[15]=1;//读取一个对象属性请求             [1] GetRequestNormal
			p8tx[16]=UARTCtrl->PIID&0x3f;//PIID
			Byte=17;
			//OAD
			p8CSD[1]=0x00;
			p8CSD[2+0]=(RM_SECURITY_MeterNo_OAD>>24)&0xff;//电能表表号 或 电能表ESAM序列号
			p8CSD[2+1]=(RM_SECURITY_MeterNo_OAD>>16)&0xff;
			p8CSD[2+2]=(RM_SECURITY_MeterNo_OAD>>8)&0xff;
			p8CSD[2+3]=RM_SECURITY_MeterNo_OAD&0xff;
			for(i=0;i<4;i++)
			{
				p8tx[Byte+i]=p8CSD[2+i];
			}
			Byte+=4;
		//时间标签
			p8tx[Byte]=0;
			Byte+=1;
		//帧校验FCS  2Byte(是对整帧除起始字符、结束字符和FCS本身之外的所有字节的校验)
		//结束字符（16H）
			Byte+=3;
			Byte-=2;
			p8tx[1]=Byte;
			p8tx[2]=Byte>>8;
			Uart_698_HCSFCS(p8tx);//整帧校验计算(HCS和FCS),同时加结束0x16;返回0=正确，1=错误
			return Byte+2;
		}
		p8tx[14]=0x10;
		p8tx[15]=0;//明文应用数据单元 [0] 密文应用数据单元 [1]
		p8tx[16]=x;//octet-string长度
		Byte+=3;
		p8tx[Byte]=1;//随机数 [1]  RN
		p8tx[Byte+1]=16;//长度
		Byte+=2;
		i=TESAM_CMD_TxRx(0x80040010,0,0);//发送ESAM命令;返回:0=正确发收且返回9000,1=错误
		if(i)
		{
			UART7Ctrl->Task=0;//关电源重启
		}
		MR((u32)p8tx+Byte,ADDR_UART7Rx+5,16);
		MR((u32)&UARTCtrl->Rand,ADDR_UART7Rx+5,16);//抄表安全模式时发送给电表的16字节随机数
		Byte+=16;
	}
//帧校验FCS  2Byte(是对整帧除起始字符、结束字符和FCS本身之外的所有字节的校验)
//结束字符（16H）
	Byte+=3;
	Byte-=2;
	p8tx[1]=Byte;
	p8tx[2]=Byte>>8;
	Uart_698_HCSFCS(p8tx);//整帧校验计算(HCS和FCS),同时加结束0x16;返回0=正确，1=错误
	return Byte+2;
}

u8* DL698_MeterAutoReport_RM_CSD(u32 PORTn)//DL698主动上报抄表CSD;返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
{
	u32 i;
	u32 id;
	u8* p8s;
	u8* p8d;
	u32 array;
	u32 OAD;
	UARTCtrl_TypeDef* UARTCtrl;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	UARTCtrl->RMCSD[0]=DataType_CSD;
	UARTCtrl->RMCSD[1]=1;//ROAD
	OAD=UARTCtrl->RMCSD[2]<<24;
	OAD|=UARTCtrl->RMCSD[3]<<16;
	OAD|=UARTCtrl->RMCSD[4]<<8;
	OAD|=UARTCtrl->RMCSD[5];
	UARTCtrl->RMCSD[6]=0;//关联OAD个数
	
	//先查根据通知采集指定事件数据
	p8s=(u8*)ADDR_6016_SDRAM;
	for(id=0;id<NUMmax_6016;id++)
	{
		if(p8s[0]==DataType_structure)
		{
//0	array ROAD	周期采集事件数据
//1	NULL	根据通知采集所有事件数据
//2	array ROAD	根据通知采集指定事件数据
//3	NULL 根据通知存储生成的事件数据
			//if(p8s[7]==2)//2	array ROAD	根据通知采集指定事件数据
			if((p8s[7]==0)||(p8s[7]==2))//周期采集事件数据 或 根据通知采集指定事件数据
			{
				if(p8s[8]==DataType_array)
				{
					p8d=p8s+9;
					array=Get_DL698ByteTypeLenValue(p8d);//得到DL698字节类型长度单元的值
					p8d+=Get_DL698ByteTypeLenByte(p8d);//得到DL698字节类型用来表示长度单元的字节数
					while(array--)
					{
						if(p8d[0]==DataType_ROAD)
						{
							i=p8d[1]<<24;
							i|=p8d[2]<<16;
							i|=p8d[3]<<8;
							i|=p8d[4];
							if(i==OAD)
							{//找到
								i=Get_DL698DataLen_S(p8d,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
								if(((i+1)>sizeof(UARTCtrl->RMCSD))||(i<6))
								{
									return 0;//返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
								}
								//ROAD转为普通方案的RCSD格式，
								if(i)
								{
									i--;
								}
								UARTCtrl->RMCSD[0]=DataType_CSD;
								UARTCtrl->RMCSD[1]=1;
								MR(((u32)&UARTCtrl->RMCSD)+2,(u32)p8d+1,i);
								return (u8*)1;//返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
							}
						}
						i=Get_DL698DataLen_S(p8d,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
						p8d+=i;
					}
				}
			}
		}
		p8s+=LENper_6016;
	}
/*
	//查根据通知采集所有事件数据
	p8s=(u8*)ADDR_6016_SDRAM;
	for(id=0;id<NUMmax_6016;id++)
	{
		if(p8s[0]==DataType_structure)
		{
			if(p8s[7]==1)//1	NULL	根据通知采集所有事件数据
			{
				return (u8*)1;
			}
		}
		p8s+=LENper_6016;
	}
*/
	return 0;//返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
}


void MeterAutoReport_RS485(u32 PORTn)//电能表主动上报任务-RS485:0=空,1=有主动上报等待读取,2...抄读中
{
	u32 i;
	u32 n;
	u8* p8tx;
	u8* p8rx;
	u16* p16timer;
	UARTCtrl_TypeDef* UARTCtrl;
	u8* p8Data;
	RecordFileHead_TypeDef* RecordFileHead;
	u32 Byte;
	u32 x;
	u16* p16;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	p8tx=(u8 *)Get_ADDR_UARTnTx(PORTn);
	p8rx=(u8 *)Get_ADDR_UARTnRx(PORTn);
	p16timer=(u16 *)Get_ADDR_UARTnTimer(PORTn);
	switch(UARTCtrl->AutoReportTask)//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
	{
		default:
			//UARTCtrl->TaskID=0;
			UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
			UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
			break;
		case 2://按规约抄读
			MR((u32)&UARTCtrl->RMAddr,(u32)&UARTCtrl->AutoReportRMAddr,6);
			UARTCtrl->RMprotocol=UARTCtrl->AutoReportRMprotocol;
			if(UARTCtrl->AutoReportRMprotocol==2)//抄表规约类型=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
			{//645
				Data_Inverse((u32)&UARTCtrl->RMAddr,6);//同698地址顺序
				UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			}
			else
			{//698
				UARTCtrl->AutoReportTask=10;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			}
			RM_ADDR_Display(PORTn);//抄表地址显示
			
			UARTCtrl->RMCSDCount=0;//抄表计数
			UARTCtrl->RMCSDSubCount=0;//抄表CSD子计数
//接收数据缓冲定义：
//typedef __packed struct
//{
//	u16 Addr0;
//	u16 Addr1;
//	u16 Addr2;
//	u16 LEN_DATA;
//}RecordFileHead_TypeDef;//抄表记录文件头
//0 4byte 数据来源端口号 OAD
//4 1byte 帧条数
//5 帧数据octet-string	
			RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
			p8Data=(u8*)RecordFileHead+sizeof(RecordFileHead_TypeDef);
			MR((u32)RecordFileHead,(u32)&UARTCtrl->RMAddr,6);//地址
			i=PORTntoOAD(PORTn);//通信口号转为OAD值
			p8Data[0]=i>>24;
			p8Data[1]=(i>>16)&0xff;
			p8Data[2]=(i>>8)&0xff;
			p8Data[3]=(i>>0)&0xff;
			p8Data[4]=0;//帧条数
			RecordFileHead->LEN_DATA=5;//帧数据总长度
			if(UARTCtrl->AutoReportRMprotocol==2)//抄表规约类型=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
			{//645
				MeterAutoReportStateWord_B0toB95(PORTn);//主动上报状态字分解为B0-B95新增次数,若有没对应事件的发生位，状态字作为1条事件
			}
			break;
			
//---DL645---
		case 3://发645抄读
			if(p16timer[0]!=0)
			{
				break;
			}
			i=MeterAutoReport_TxDATA_DL2007(PORTn,p8tx+4);//DL645主动上报抄表发送帧;返回:组帧后总长度字节数
			if(i==0)
			{//结束
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
				return;
			}
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			i+=4;
			UARTCtrl->TxByte=i;
			UARTCtrl->Task=3;//3=启动发送
			UARTCtrl->TxToRxTimerOver=RMRS485OverTimer/10;//发送后接收超时定时值ms/10(半字对齐)
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 4://接收645抄读
			RS485_RxTx(PORTn);//UART_DL645接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			switch(UARTCtrl->Task)//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				default://3=启动发送,4=正在发送,5=正在接收
					break;
				case 0://0=空闲
				case 2://2超时
					if(UARTCtrl->ReRMCount<3)
					{//重发计数
						UARTCtrl->ReRMCount++;
						i=p8tx[4+9];
						i+=12;
						i+=4;
						UARTCtrl->TxByte=i;
						UARTCtrl->Task=3;//3=启动发送
						break;
					}
					UARTCtrl->Task=0;
					UARTCtrl->RMCSDSubCount++;//子计数+1
					UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					break;
				case 1://1完成接收
					UARTCtrl->Task=5;//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
					UARTCtrl->RMCSDSubCount++;//子计数+1
					UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					p16timer[0]=30/10;//下帧发送延时
					i=RM_RxDATA_DL2007_CHECK(PORTn);//DL645_2007帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回0正确,1地址错,2控制码错,3数据标识错
					switch(UARTCtrl->RMCSDCount)
					{
						default:
							if((i==1)||(i==3))
							{//1地址错,3数据标识错
								break;
							}
							DL645_68H_Add33H_CS_16H(p8rx);//DL465帧起始符0x68,数据域加0x33,CS,结尾0x16
							DL645_MeterAutoReport_RxDataBuff(PORTn,p8rx);//dl645读到的电能表主动上报事件数据缓存
							break;
						case 96://复位主动上报状态字
							UARTCtrl->RMCSDSubCount=0;//子计数
							UARTCtrl->RMCSDCount++;
							break;
						case 97://再次读主动上报状态字
							i=p8rx[10];
							i|=p8rx[10+1]<<8;
							i|=p8rx[10+2]<<16;
							i|=p8rx[10+3]<<24;
							if(i==0x04001501)
							{//主动上报状态字
								if(p8rx[9]<=(4+12))
								{//长度错或老格式(只有10字节状态字)
									break;//结束
								}
								for(i=0;i<12;i++)
								{
									if(p8rx[14+i]!=0)
									{
										break;
									}
								}
								if(i>=12)
								{//状态字内容全0,结束
									//b0-b95抄读的数据存贮
									RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
									p8Data=(u8*)RecordFileHead+sizeof(RecordFileHead_TypeDef);
									n=p8Data[4];//帧条数
									if(n)
									{//有数据
										MeterAutoReport_Record(PORTn,(u8*)RecordFileHead,MeterAutoReportFileID_DL645);//电能表主动上报记录文件;入口:pDATA=数据指针(分别为RecordFileHead+时标+帧个数和长度+数据)
									}
									//UARTCtrl->TaskID=0;
									UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
									UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
									UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
									return;
								}
								UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
								MeterAutoReportStateWord(PORTn,p8rx);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
								MeterAutoReportStateWord_B0toB95(PORTn);//主动上报状态字分解为B0-B95新增次数,若有没对应事件的发生位，状态字作为1条事件
								UARTCtrl->RMCSDCount=0;//抄表计数
								UARTCtrl->RMCSDSubCount=0;//抄表CSD子计数
								UARTCtrl->AutoReportTask=3;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
							}
							break;
					}
					break;
			}
			break;
//---DL645 END---
			
//---DL698---
		case 10://发698抄读新增事件
			UARTCtrl->RM_Rx_date_40020200[0]=0;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
			UARTCtrl->RMCSD[2+0]=0x33;//属性 2（新增 上报 事件列表 ，只读）∷= array  OAD
			UARTCtrl->RMCSD[2+1]=0x20;
			UARTCtrl->RMCSD[2+2]=0x02;
			UARTCtrl->RMCSD[2+3]=0x00;
			i=MeterAutoReport_TxDATA_DL698(PORTn,(u8*)&UARTCtrl->RMCSD,p8tx+4);//DL698主动上报抄表发送帧;返回:组帧后总长度字节数
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			i+=4;
			UARTCtrl->TxByte=i;
			UARTCtrl->Task=3;//3=启动发送
			UARTCtrl->TxToRxTimerOver=RMRS485OverTimer/10;//发送后接收超时定时值ms/10(半字对齐)
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 11://接收698抄读新增事件
			RS485_RxTx(PORTn);//UART_DL645接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			switch(UARTCtrl->Task)//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				default://3=启动发送,4=正在发送,5=正在接收
					break;
				case 0://0=空闲
				case 2://2超时
					if(UARTCtrl->ReRMCount<3)
					{//重发计数
						UARTCtrl->ReRMCount++;
						i=p8tx[4+1]+(p8tx[4+2]<<8);
						i+=4+2;
						UARTCtrl->TxByte=i;
						UARTCtrl->Task=3;//3=启动发送
						break;
					}
					UARTCtrl->Task=0;
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
					break;
				case 1://1完成接收
					p16timer[0]=30/10;//下帧发送延时
					i=RM_RxDATA_CHECK(PORTn);//帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回:0=正确,1=地址错,2=控制码错,3=数据标识错
					if(i!=0)
					{//错误
						UARTCtrl->Task=0;
						//UARTCtrl->TaskID=0;
						UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
						UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
						UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
						return;
					}
					if(UARTCtrl->RM_Rx_date_40020200[0]==1)//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
					{
//68 23 00 C3 05 01 00 00 00 00 00 00 EA EF 85 01 01 40 02 02 00 01 09 08 00 00 00 00 00 00 00 00 00 00 66 5F 16
						p8rx+=22;
						MC(0,((u32)&UARTCtrl->RM_Rx_date_40020200)+2,8);
						i=p8rx[1];//表号长度
						if(i>8)
						{
							i=8;
						}
						UARTCtrl->RM_Rx_date_40020200[1]=i;
						x=8-i;
						MR(((u32)&UARTCtrl->RM_Rx_date_40020200)+2+x,(u32)p8rx+2,i);
						UARTCtrl->RM_Rx_date_40020200[0]=2;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
						
						UARTCtrl->RMCSD[2+0]=0x33;//属性 2（新增 上报 事件列表 ，只读）∷= array  OAD
						UARTCtrl->RMCSD[2+1]=0x20;
						UARTCtrl->RMCSD[2+2]=0x02;
						UARTCtrl->RMCSD[2+3]=0x00;
						i=MeterAutoReport_TxDATA_DL698(PORTn,(u8*)&UARTCtrl->RMCSD,p8tx+4);//DL698主动上报抄表发送帧;返回:组帧后总长度字节数
						p8tx[0]=0xfe;
						p8tx[1]=0xfe;
						p8tx[2]=0xfe;
						p8tx[3]=0xfe;
						i+=4;
						UARTCtrl->TxByte=i;
						UARTCtrl->Task=3;//3=启动发送
						UARTCtrl->TxToRxTimerOver=RMRS485OverTimer/10;//发送后接收超时定时值ms/10(半字对齐)
						UARTCtrl->ReRMCount=0;//重发计数
						return;
					}
					i=Get_DL698DataLen_S(p8rx+22,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
					if(i>sizeof(UARTCtrl->AutoReportData))
					{
						p8rx[24]=1;//数组数改为1
						i=Get_DL698DataLen_S(p8rx+22,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
						if(i>sizeof(UARTCtrl->AutoReportData))
						{//错误
							UARTCtrl->Task=0;
							//UARTCtrl->TaskID=0;
							UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
							UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
							UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
							return;
						}
					}
					if(p8rx[24]==0)//新增事件数组数
					{
						UARTCtrl->Task=0;
						//UARTCtrl->TaskID=0;
						UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
						UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
						UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
						return;
					}
					MR((u32)&UARTCtrl->AutoReportData,(u32)p8rx+22,i);
					UARTCtrl->RMCSDCount=0;//抄表计数
					UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					DL698_MeterAutoReport_RxDATA_START(PORTn);//抄表接收数据处理-开始
					break;
			}
			break;
		case 12://发698抄读事件
			i=UARTCtrl->RMCSDCount;
			if(i>=UARTCtrl->AutoReportData[1])
			{//抄完
				RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
				p16=(u16 *)Get_ADDR_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲地址
				p16+=(LEN_RM_DI_CSD)/2;//已填写入buff完整CSD的长度
				i=p16[1];
				if(i>2)
				{//有数据填入
					DL698_MeterAutoReport_RxDATA_END(PORTn);//抄表接收数据处理-结束
					MeterAutoReport_Record(PORTn,(u8*)RecordFileHead,MeterAutoReportFileID_DL698);//电能表主动上报记录文件;入口:pDATA=数据指针(分别为RecordFileHead+时标+帧个数和长度+数据)
					//清抄表成功判断数据
					p16[1]=0;
				}
			#if (USER%100)==0//电科科测试
				UARTCtrl->AutoReportTask=10;//10=发698抄读新增事件
			#else
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
			#endif
				return;
			}
			p8Data=Get_Element((u8*)&UARTCtrl->AutoReportData,i+1,0,0);//计算元素地址(虚拟地址指针),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
			if(p8Data==0)
			{
				UARTCtrl->RMCSDCount=UARTCtrl->AutoReportData[1];
				return;
			}
			i=Get_DL698DataLen_S(p8Data,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
			if(i>(LEN_RMCSD-1))
			{
				i=LEN_RMCSD;
			}
			MR((u32)UARTCtrl->RMCSD+1,(u32)p8Data,i);
			p8tx+=4;
			
		//起始字符（68H）  1Byte
			p8tx[0]=0x68;
		//长度域L  2Byte(除起始字符和结束字符之外的帧字节数)
		//控制域C  1Byte
			p8tx[3]=0x43;
		//地址域A
			p8tx[4]=5;
			p8tx[5]=UARTCtrl->RMAddr[2]>>8;
			p8tx[6]=UARTCtrl->RMAddr[2];
			p8tx[7]=UARTCtrl->RMAddr[1]>>8;
			p8tx[8]=UARTCtrl->RMAddr[1];
			p8tx[9]=UARTCtrl->RMAddr[0]>>8;
			p8tx[10]=UARTCtrl->RMAddr[0];
		//客户机地址CA  1Byte
			p8tx[11]=0;
		//帧头校验HCS  2Byte(帧头校验HCS为2字节，是对帧头部分除起始字符和HCS本身之外的所有字节的校验)
		//空出3字节，当安全模式读取时用
			p8tx+=3;
		//APDU
			//05 03 0E 31 0F 02 00 09 01 03 00 20 22 02 00 00 20 1E 02 00 00 20 20 02 00 00
			p8tx[14]=5;//GET-Request
			p8tx[15]=3;//读取一个记录型对象属性请求       [3] GetRequestRecord
			UARTCtrl->PIID++;
			p8tx[16]=UARTCtrl->PIID&0x3f;//PIID
			Byte=17;
			//OAD
			for(i=0;i<4;i++)
			{
				p8tx[Byte+i]=UARTCtrl->RMCSD[2+i];
			}
			Byte+=4;
			//选择方法
			p8tx[Byte]=9;//RSD， 选择方法9:Selector9为指定选取上第n次记录
			p8tx[Byte+1]=1;//上第n次记录  unsigned
			Byte+=2;
			
			//RCSD，SEQUENCE OF个数
			i=(u32)DL698_MeterAutoReport_RM_CSD(PORTn);//DL698主动上报抄表CSD;返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
			if((i==0)||(UARTCtrl->RMCSD[6]==0))
			{//!!!测试台模拟表不支持SEQUENCE OF个数=0抄表
				x=0;//UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				p8tx[Byte]=x;//SEQUENCE OF个数=0表示全选
				Byte++;
		//---当不为全选时---
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件记录序号
				p8tx[Byte+2]=0x22;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x22;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件发生时间
				p8tx[Byte+2]=0x1E;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x1e;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件结束时间
				p8tx[Byte+2]=0x20;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件发生源
				p8tx[Byte+2]=0x24;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x24;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
		//---当不为全选时  END---
				p8tx-=5*x;
				p8tx--;
				p8tx[Byte]=x;//UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				UARTCtrl->RMCSD[0]=DataType_CSD;
				UARTCtrl->RMCSD[1]=1;//记录型对象属性描述符 [1] ROAD
				UARTCtrl->RMCSD[6]=x;
				p8tx++;
				p8tx+=5*x;
			}
			else
			{
				x=UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				p8tx[Byte]=x;
				Byte++;
				for(i=0;i<x;i++)
				{
					p8tx[Byte+0]=0;//类型=OAD
					p8tx[Byte+1]=UARTCtrl->RMCSD[7+(i*4)+0];//OAD
					p8tx[Byte+2]=UARTCtrl->RMCSD[7+(i*4)+1];//OAD
					p8tx[Byte+3]=UARTCtrl->RMCSD[7+(i*4)+2];//OAD
					p8tx[Byte+4]=UARTCtrl->RMCSD[7+(i*4)+3];//OAD
					Byte+=5;
				}
			}
		//时间标签
			p8tx[Byte]=0;
			Byte+=1;
		//安全模式读取
			p8tx-=3;//空出的3字节
			x=Byte-14;//APDU长度
			i=(UARTCtrl->RMCSD[2]<<8)|UARTCtrl->RMCSD[3];
			i=RM_SECURITY(i);//抄表安全模式字,入口:OI,出口:(同安全请求)b7=0无安全=1安全传输,b6=0明文=1密文,b5=,b4=,b3-b0=0数据验证码[0]SID_MAC =1随机数[1]RN =2随机数+数据MAC[2]RN_MAC =3安全标识[3]SID
			if(i==0)
			{//明文读取
				for(i=0;i<x;i++)
				{
					p8tx[14+i]=p8tx[17+i];
				}
			}
			else
			{//明文+数据验证码读取
				p8tx[14]=0x10;
				p8tx[15]=0;//明文应用数据单元 [0] 密文应用数据单元 [1]
				p8tx[16]=x;//octet-string长度
				Byte+=3;
				p8tx[Byte]=1;//随机数 [1]  RN
				p8tx[Byte+1]=16;//长度
				Byte+=2;
				i=TESAM_CMD_TxRx(0x80040010,0,0);//发送ESAM命令;返回:0=正确发收且返回9000,1=错误
				if(i)
				{
					UART7Ctrl->Task=0;//关电源重启
				}
				MR((u32)p8tx+Byte,ADDR_UART7Rx+5,16);
				MR((u32)&UARTCtrl->Rand,ADDR_UART7Rx+5,16);//抄表安全模式时发送给电表的16字节随机数
				Byte+=16;
			}
		//帧校验FCS  2Byte(是对整帧除起始字符、结束字符和FCS本身之外的所有字节的校验)
		//结束字符（16H）
			Byte+=3;
			Byte-=2;
			p8tx[1]=Byte;
			p8tx[2]=Byte>>8;
			Uart_698_HCSFCS(p8tx);//整帧校验计算(HCS和FCS),同时加结束0x16;返回0=正确，1=错误
			Byte+=2;
			
			p8tx-=4;
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			Byte+=4;
			UARTCtrl->TxByte=Byte;
			UARTCtrl->Task=3;//3=启动发送
			UARTCtrl->TxToRxTimerOver=RMRS485OverTimer/10;//发送后接收超时定时值ms/10(半字对齐)
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 13://接收698抄读事件
			RS485_RxTx(PORTn);//UART_DL645接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			switch(UARTCtrl->Task)//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				default://3=启动发送,4=正在发送,5=正在接收
					break;
				case 0://0=空闲
				case 2://2超时
					if(UARTCtrl->ReRMCount<3)
					{//重发计数
						UARTCtrl->ReRMCount++;
						i=p8tx[4+1]+(p8tx[4+2]<<8);
						i+=4+2;
						UARTCtrl->TxByte=i;
						UARTCtrl->Task=3;//3=启动发送
						break;
					}
					UARTCtrl->Task=0;
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
					break;
				case 1://1完成接收
					p16timer[0]=30/10;//下帧发送延时
					i=RM_RxDATA_CHECK(PORTn);//帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回:0=正确,1=地址错,2=控制码错,3=数据标识错
					if(i!=0)
					{//错误
					#if (USER/100)==0//是电科院测试
						
					#else
						UARTCtrl->Task=0;
						//UARTCtrl->TaskID=0;
						UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
						UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
						UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
						return;
					#endif
					}
					//if(i==0)
					//{
						DL698_MeterAutoReport_RxDATA(PORTn,p8rx);//DL698读到的电能表主动上报事件数据缓存;返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
					//}
					UARTCtrl->RMCSDCount++;//抄表计数
					UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					break;
			}
			break;
//---DL698 END---
	}
}



#if ((Project/100)==2)||((Project/100)==4)//方案0=智能表,100=网络表,200=集中器,300=专变终端,400=公变终端,500=集中器Ⅱ型,600=通信模块,700=
void MeterAutoReport_3762(u32 PORTn)//电能表主动上报任务-3762:0=空,1=有主动上报等待读取,2...抄读中
{
	u32 i;
	u32 x;
	u32 n;
	u8* p8tx;
	u8* p8rx;
	u16* p16timer;
	UARTCtrl_TypeDef* UARTCtrl;
	u8* p8Data;
	RecordFileHead_TypeDef* RecordFileHead;
	u64 d64;
	u32 Byte;
	u16* p16;
	
	UARTCtrl=(UARTCtrl_TypeDef *)Get_ADDR_UARTnCtrl(PORTn);
	p8tx=(u8 *)Get_ADDR_UARTnTx(PORTn);
	p8rx=(u8 *)Get_ADDR_UARTnRx(PORTn);
	p16timer=(u16 *)Get_ADDR_UARTnTimer(PORTn);
	switch(UARTCtrl->AutoReportTask)//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
	{
		default:
			Terminal_Router->RouterInitTask=0;//路由器抄读任务0-99公共初始化,100-199分厂家初始化,>=200路由抄表
			//UARTCtrl->TaskID=0;
			UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
			UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 2://暂停路由
			Terminal_Router->StopFlags|=(1<<17);//暂停路由
			Terminal_Router->RouterCtrl=2;//路由器控制0=空,1=重启,2=暂停,3=恢复;完成后自动回到0
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 3://
			MR((u32)&UARTCtrl->RMAddr,(u32)&UARTCtrl->AutoReportRMAddr,6);
			UARTCtrl->RMprotocol=UARTCtrl->AutoReportRMprotocol;
			if(UARTCtrl->AutoReportRMprotocol==2)//抄表规约类型=未知 (0)，DL/T645-1997（1），DL/T645-2007（2），DL/T698.45（3），CJ/T 188-2004（4）
			{//645
				Data_Inverse((u32)&UARTCtrl->RMAddr,6);//同698地址顺序
				UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			}
			else
			{//698
				Data_Inverse((u32)&UARTCtrl->RMAddr,6);//同698地址顺序
				UARTCtrl->RM_Rx_date_40020200[0]=0;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
				UARTCtrl->AutoReportTask=10;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			}
			RM_ADDR_Display(PORTn);//抄表地址显示
			
			UARTCtrl->RMCSDCount=0;//抄表计数
			UARTCtrl->RMCSDSubCount=0;//抄表CSD子计数
//接收数据缓冲定义：
//typedef __packed struct
//{
//	u16 Addr0;
//	u16 Addr1;
//	u16 Addr2;
//	u16 LEN_DATA;
//}RecordFileHead_TypeDef;//抄表记录文件头
//0 4byte 数据来源端口号 OAD
//4 1byte 帧条数
//5  帧数据octet-string	
			RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
			p8Data=(u8*)RecordFileHead+sizeof(RecordFileHead_TypeDef);
			MR((u32)RecordFileHead,(u32)&UARTCtrl->RMAddr,6);//地址
			i=PORTntoOAD(PORTn);//通信口号转为OAD值
			p8Data[0]=i>>24;
			p8Data[1]=(i>>16)&0xff;
			p8Data[2]=(i>>8)&0xff;
			p8Data[3]=(i>>0)&0xff;
			p8Data[4]=0;//帧条数
			RecordFileHead->LEN_DATA=5;//帧数据总长度
			MeterAutoReportStateWord_B0toB95(PORTn);//主动上报状态字分解为B0-B95新增次数,若有没对应事件的发生位，状态字作为1条事件
			break;
			
	//---DL645---
		case 4://发645抄读
			p8tx+=256;
			i=MeterAutoReport_TxDATA_DL2007(PORTn,p8tx+4);//DL645主动上报抄表发送帧;返回:组帧后总长度字节数
			if(i==0)
			{//结束
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
					return;
				}
				Terminal_Router->StopFlags&=~(1<<17);//恢复路由
				//Terminal_Router->RouterCtrl=3;//路由器控制命令0=空,1=重启,2=暂停,3=恢复,4=检测;完成后自动回到0
				return;
			}
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			i+=4;
			Uart_3762_AFN13F1_Tx(PORTn,2,(u32)p8tx,i,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
			p8tx-=256;
		#if SEL_RouterRunMode3ADDR==1//微功率无线发送帧目标地址:0=电能表地址，1=采集器地址
			if(Terminal_Router->RouterRunMode_1==3)//路由运行模式_通信方式：1表示"窄带电力线载波通信"，2表示"宽带电力线载波通信"，3表示"微功率无线通信"，其它取值保留
			{//微功率无线,目标地址用采集器地址
				x=AddrToMeterSetNo((u16*)&UARTCtrl->RMAddr);//搜索通信地址在采集档案配置表中的序号;返回:从0开始的配置序号,>=RMNmax表示无效
				p8Data=(u8*)ADDR_6000_SDRAM+(x*LENper_6000);
				p8Data=Get_Element(p8Data,3,0,0);//计算元素地址
				if((x>=NUM_RMmax)||(p8Data==0))
				{//没找到配置序号
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					//取主动上报缓存帧
					i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
					if(i)
					{
						MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
						MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
						i--;
						UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
						UARTCtrl->AutoReportTask=3;//跳过暂停路由
						return;
					}
					Terminal_Router->StopFlags&=~(1<<17);//恢复路由
					//Terminal_Router->RouterCtrl=3;//路由器控制0=空,1=重启,2=暂停,3=恢复,4=读状态;完成后自动回到0
					return;
				}
				//d64=MRR((u32)p8Data+4,6);//取配置采集器地址
				d64=Get_TSA_Value(p8Data+3);//得到TSA的不大于6字节通信地址,数据顺序不变,入口:p8=TSA类型后的字节，若无效值则=0
				if((d64!=0)&&(d64!=0xeeeeeeeeeeee))
				{
					d64=R_Inverse(d64,6);//寄存器数据倒序(高低字节调换),入口:Data=寄存器中数据,Byte=需倒序的字节数;返回:倒序后的数据
					MWR(d64,((u32)p8tx)+16,6);//从节点地址(目的地址)
					Uart_3762_CS((u32)p8tx);//和校验计算并写入(同时写入结束0x16)和比较,返回0=正确1=错误,入口接收或发送缓冲
				}
			}
		#endif
			UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
			UARTCtrl->TxToRxTimerOver=Terminal_Router->MaxOverTime*(1000/10);//从节点监控最大超时时间秒
			UARTCtrl->Task=3;//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 5://接收645抄读
			if(UARTCtrl->Task>=3)//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				break;
			}
			if(UARTCtrl->Task!=1)//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{//0=空闲,2超时
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
				UARTCtrl->Task=0;
				UARTCtrl->RMCSDSubCount++;//子计数+1
				UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				break;
			}
			//1完成接收
			i=MRR(((u32)p8rx)+22,3);
			if(i!=0x113)
			{//AFN=13H,Fn=1
				//继续接收
				p16timer=(u16 *)Get_ADDR_UARTnTimer(PORTn);
				p16timer[0]=1000/10;
				UARTCtrl->RxByte=0;
				UARTCtrl->Task=5;//5=正在接收
				return;
			}
			x=p8rx[28];//返回数据域长度
			if(x==0)
			{//接收数据长度=0
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
				UARTCtrl->Task=0;
				UARTCtrl->RMCSDSubCount++;//子计数+1
				UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				break;
			}
			MR((u32)p8rx,((u32)p8rx)+28+1,x);
			for(i=0;i<x;i++)
			{//去返回645帧的前导0xfe
				if(p8rx[i]!=0xfe)
				{
					if(i!=0)
					{
						MR((u32)p8rx,((u32)p8rx)+i,x-i);
					}
					break;
				}
			}
			UARTCtrl->Task=5;//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			UARTCtrl->RMCSDSubCount++;//子计数+1
			UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			p16timer[0]=30/10;//下帧发送延时
			i=RM_RxDATA_DL2007_CHECK(PORTn);//DL645_2007帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回0正确,1地址错,2控制码错,3数据标识错
			switch(UARTCtrl->RMCSDCount)
			{
				default:
					if((i==1)||(i==3))
					{//1地址错,3数据标识错
						break;
					}
					DL645_68H_Add33H_CS_16H(p8rx);//DL465帧起始符0x68,数据域加0x33,CS,结尾0x16
					DL645_MeterAutoReport_RxDataBuff(PORTn,p8rx);//读到的电能表主动上报事件数据缓存
					break;
				case 96://复位主动上报状态字
					UARTCtrl->RMCSDSubCount=0;//子计数
					UARTCtrl->RMCSDCount++;
					break;
				case 97://再次读主动上报状态字
					i=p8rx[10];
					i|=p8rx[10+1]<<8;
					i|=p8rx[10+2]<<16;
					i|=p8rx[10+3]<<24;
					if(i==0x04001501)
					{//主动上报状态字
						if(p8rx[9]<=(4+12))
						{//长度错或老格式(只有10字节状态字)
							break;//结束
						}
						for(i=0;i<12;i++)
						{
							if(p8rx[14+i]!=0)
							{
								break;
							}
						}
						if(i>=12)
						{//状态字内容全0,结束
							//b0-b95抄读的数据存贮
							RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
							p8Data=(u8*)RecordFileHead+sizeof(RecordFileHead_TypeDef);
							n=p8Data[4];//帧条数
							if(n)
							{//有数据
								MeterAutoReport_Record(PORTn,(u8*)RecordFileHead,MeterAutoReportFileID_DL645);//电能表主动上报记录文件;入口:pDATA=数据指针(分别为RecordFileHead+时标+帧个数和长度+数据)
							}
							//UARTCtrl->TaskID=0;
							UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
							UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
							//取主动上报缓存帧
							i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
							if(i)
							{
								MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
								MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
								i--;
								UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
								UARTCtrl->AutoReportTask=3;//跳过暂停路由
							}
							return;
						}
						UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
						MeterAutoReportStateWord(PORTn,p8rx);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
						MeterAutoReportStateWord_B0toB95(PORTn);//主动上报状态字分解为B0-B95新增次数,若有没对应事件的发生位，状态字作为1条事件
						UARTCtrl->RMCSDCount=0;//抄表计数
						UARTCtrl->RMCSDSubCount=0;//抄表CSD子计数
						UARTCtrl->AutoReportTask=4;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					}
					break;
			}
			break;
	//---DL645 END---
			
	//---DL698---
		case 10://发698抄读新增事件
			UARTCtrl->RMCSD[2+0]=0x33;//属性 2（新增 上报 事件列表 ，只读）∷= array  OAD
			UARTCtrl->RMCSD[2+1]=0x20;
			UARTCtrl->RMCSD[2+2]=0x02;
			UARTCtrl->RMCSD[2+3]=0x00;
			p8tx+=256;
			i=MeterAutoReport_TxDATA_DL698(PORTn,(u8*)&UARTCtrl->RMCSD,p8tx+4);//DL698主动上报抄表发送帧;返回:组帧后总长度字节数
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			i+=4;
		#if (USER/100)==0//电科院测试验
			Uart_3762_AFN13F1_Tx(PORTn,3,(u32)p8tx,i,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
		#else
			if(Comm_Ram->RouterType==2)//路由器类型:0=保留,1=正泰,2=鼎信,3=东软,4=晓晨,5=瑞斯康,6=力合微,7=讯能,8=钱龙
			{//鼎信无698暂用透明
				Uart_3762_AFN13F1_Tx(PORTn,0,(u32)p8tx,i,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
			}
			else
			{
				Uart_3762_AFN13F1_Tx(PORTn,3,(u32)p8tx,i,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
			}
		#endif
			p8tx-=256;
		#if SEL_RouterRunMode3ADDR==1//微功率无线发送帧目标地址:0=电能表地址，1=采集器地址
			if(Terminal_Router->RouterRunMode_1==3)//路由运行模式_通信方式：1表示"窄带电力线载波通信"，2表示"宽带电力线载波通信"，3表示"微功率无线通信"，其它取值保留
			{//微功率无线,目标地址用采集器地址
				x=AddrToMeterSetNo((u16*)&UARTCtrl->RMAddr);//搜索通信地址在采集档案配置表中的序号;返回:从0开始的配置序号,>=RMNmax表示无效
				p8Data=(u8*)ADDR_6000_SDRAM+(x*LENper_6000);
				p8Data=Get_Element(p8Data,3,0,0);//计算元素地址
				if((x>=NUM_RMmax)||(p8Data==0))
				{//没找到配置序号
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					//取主动上报缓存帧
					i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
					if(i)
					{
						MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
						MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
						i--;
						UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
						UARTCtrl->AutoReportTask=3;//跳过暂停路由
						return;
					}
					Terminal_Router->StopFlags&=~(1<<17);//恢复路由
					//Terminal_Router->RouterCtrl=3;//路由器控制0=空,1=重启,2=暂停,3=恢复,4=读状态;完成后自动回到0
					return;
				}
				//d64=MRR((u32)p8Data+4,6);//取配置采集器地址
				d64=Get_TSA_Value(p8Data+3);//得到TSA的不大于6字节通信地址,数据顺序不变,入口:p8=TSA类型后的字节，若无效值则=0
				if((d64!=0)&&(d64!=0xeeeeeeeeeeee))
				{
					d64=R_Inverse(d64,6);//寄存器数据倒序(高低字节调换),入口:Data=寄存器中数据,Byte=需倒序的字节数;返回:倒序后的数据
					MWR(d64,((u32)p8tx)+16,6);//从节点地址(目的地址)
					Uart_3762_CS((u32)p8tx);//和校验计算并写入(同时写入结束0x16)和比较,返回0=正确1=错误,入口接收或发送缓冲
				}
			}
		#endif
			UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
			UARTCtrl->TxToRxTimerOver=Terminal_Router->MaxOverTime*(1000/10);//从节点监控最大超时时间秒
			UARTCtrl->Task=3;//3=启动发送
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 11://接收698抄读新增事件
			if(UARTCtrl->Task>=3)//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				break;
			}
			i=p8rx[1]+(p8rx[2]<<8);
			if((UARTCtrl->Task!=1)||(i<=16))//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{//0=空闲,2超时,或确认否认
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			}
			//1完成接收
			i=MRR(((u32)p8rx)+22,3);
			if(i!=0x113)
			{//AFN=13H,Fn=1
				//继续接收
				p16timer=(u16 *)Get_ADDR_UARTnTimer(PORTn);
				p16timer[0]=1000/10;
				UARTCtrl->RxByte=0;
				UARTCtrl->Task=5;//5=正在接收
				return;
			}
			x=p8rx[28];//返回数据域长度
			if(x==0)
			{//接收数据长度=0
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			}
			MR((u32)p8rx,((u32)p8rx)+28+1,x);
			for(i=0;i<x;i++)
			{//去返回645帧的前导0xfe
				if(p8rx[i]!=0xfe)
				{
					if(i!=0)
					{
						MR((u32)p8rx,((u32)p8rx)+i,x-i);
					}
					break;
				}
			}
			UARTCtrl->Task=5;//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			p16timer[0]=30/10;//下帧发送延时
			i=RM_RxDATA_CHECK(PORTn);//帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回:0=正确,1=地址错,2=控制码错,3=数据标识错
			if(i!=0)
			{//错误
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			}
			if(UARTCtrl->RM_Rx_date_40020200[0]==1)//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
			{
//68 23 00 C3 05 01 00 00 00 00 00 00 EA EF 85 01 01 40 02 02 00 01 09 08 00 00 00 00 00 00 00 00 00 00 66 5F 16
				p8rx+=22;
				MC(0,((u32)&UARTCtrl->RM_Rx_date_40020200)+2,8);
				i=p8rx[1];//表号长度
				if(i>8)
				{
					i=8;
				}
				UARTCtrl->RM_Rx_date_40020200[1]=i;
				x=8-i;
				MR(((u32)&UARTCtrl->RM_Rx_date_40020200)+2+x,(u32)p8rx+2,i);
				UARTCtrl->RM_Rx_date_40020200[0]=2;//抄表接收到的数据用于MAC验证的电能表表号;0th=状态(0=空,1=正在抄,2=完成),1th=表号长度(<=6),2th-7th表号值
				UARTCtrl->ReRMCount=0;//重发计数
				UARTCtrl->AutoReportTask=10;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				return;
			}
			i=Get_DL698DataLen_S(p8rx+22,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
			if(i>sizeof(UARTCtrl->AutoReportData))
			{
				p8rx[24]=1;//数组数改为1
				i=Get_DL698DataLen_S(p8rx+22,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
				if(i>sizeof(UARTCtrl->AutoReportData))
				{//错误
					UARTCtrl->Task=0;
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					//取主动上报缓存帧
					i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
					if(i)
					{
						MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
						MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
						i--;
						UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
						UARTCtrl->AutoReportTask=3;//跳过暂停路由
					}
					return;
				}
			}
			if(p8rx[24]==0)//新增事件数组数
			{
				UARTCtrl->ReRMCount=0;//重发计数
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			}
			MR((u32)&UARTCtrl->AutoReportData,(u32)p8rx+22,i);
			UARTCtrl->RMCSDCount=0;//抄表计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			DL698_MeterAutoReport_RxDATA_START(PORTn);//抄表接收数据处理-开始
			break;
		case 12://发698抄读事件
			i=UARTCtrl->RMCSDCount;
			if(i>=UARTCtrl->AutoReportData[1])
			{//抄完
				RecordFileHead=(RecordFileHead_TypeDef*)Get_ADDR_UARTnFnDataBuff(PORTn);
				p16=(u16 *)Get_ADDR_UARTnFnDataBuff(PORTn);//得到UART抄表数据缓冲地址
				p16+=(LEN_RM_DI_CSD)/2;//已填写入buff完整CSD的长度
				i=p16[1];
				if(i>2)
				{//有数据填入
					DL698_MeterAutoReport_RxDATA_END(PORTn);//抄表接收数据处理-结束
					MeterAutoReport_Record(PORTn,(u8*)RecordFileHead,MeterAutoReportFileID_DL698);//电能表主动上报记录文件;入口:pDATA=数据指针(分别为RecordFileHead+时标+帧个数和长度+数据)
					//清抄表成功判断数据
					p16[1]=0;
				}
			#if (USER%100)==0//电科科测试
				UARTCtrl->ReRMCount=0;//重发计数
				UARTCtrl->AutoReportTask=10;//10=发698抄读新增事件
			#else
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				UARTCtrl->RM_SubsequentFrames=0;//0=无读后续帧,1-n=读续帧的帧号
			#endif
				return;
			}
			p8Data=Get_Element((u8*)&UARTCtrl->AutoReportData,i+1,0,0);//计算元素地址(虚拟地址指针),使用ADDR_128KDATABUFF;出口:地址指向元素的类型字节,0=错误
			if(p8Data==0)
			{
				UARTCtrl->RMCSDCount=UARTCtrl->AutoReportData[1];
				return;
			}
			i=Get_DL698DataLen_S(p8Data,0);//得到DL698数据类型长度(包括:类型字节和数据);入口:LENmax仅取NAND数据时先读到ADDR_128KDATABUFF用,返回:长度
			if(i>(LEN_RMCSD-1))
			{
				i=LEN_RMCSD;
			}
			MR((u32)UARTCtrl->RMCSD+1,(u32)p8Data,i);
			p8tx+=256;
			p8tx+=4;
		//起始字符（68H）  1Byte
			p8tx[0]=0x68;
		//长度域L  2Byte(除起始字符和结束字符之外的帧字节数)
		//控制域C  1Byte
			p8tx[3]=0x43;
		//地址域A
			p8tx[4]=5;
			p8tx[5]=UARTCtrl->RMAddr[2]>>8;
			p8tx[6]=UARTCtrl->RMAddr[2];
			p8tx[7]=UARTCtrl->RMAddr[1]>>8;
			p8tx[8]=UARTCtrl->RMAddr[1];
			p8tx[9]=UARTCtrl->RMAddr[0]>>8;
			p8tx[10]=UARTCtrl->RMAddr[0];
		//客户机地址CA  1Byte
			p8tx[11]=0;
		//帧头校验HCS  2Byte(帧头校验HCS为2字节，是对帧头部分除起始字符和HCS本身之外的所有字节的校验)
		//空出3字节，当安全模式读取时用
			p8tx+=3;
		//APDU
			//05 03 0E 31 0F 02 00 09 01 03 00 20 22 02 00 00 20 1E 02 00 00 20 20 02 00 00
			p8tx[14]=5;//GET-Request
			p8tx[15]=3;//读取一个记录型对象属性请求       [3] GetRequestRecord
			UARTCtrl->PIID++;
			p8tx[16]=UARTCtrl->PIID&0x3f;//PIID
			Byte=17;
			//OAD
			for(i=0;i<4;i++)
			{
				p8tx[Byte+i]=UARTCtrl->RMCSD[2+i];
			}
			Byte+=4;
			//选择方法
			p8tx[Byte]=9;//RSD， 选择方法9:Selector9为指定选取上第n次记录
			p8tx[Byte+1]=1;//上第n次记录  unsigned
			Byte+=2;
			
			//RCSD，SEQUENCE OF个数
			i=(u32)DL698_MeterAutoReport_RM_CSD(PORTn);//DL698主动上报抄表CSD;返回:0=无效,1=CSD在URATCtrl,其他值=透明抄读帧数据指针
			if((i==0)||(UARTCtrl->RMCSD[6]==0))
			{//!!!测试台模拟表不支持SEQUENCE OF个数=0抄表
				x=0;//UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				p8tx[Byte]=x;//SEQUENCE OF个数=0表示全选
				Byte++;
				
		//---当不为全选时---
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件记录序号
				p8tx[Byte+2]=0x22;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x22;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件发生时间
				p8tx[Byte+2]=0x1E;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x1e;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件结束时间
				p8tx[Byte+2]=0x20;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
				p8tx[Byte+0]=0;//类型=OAD
				p8tx[Byte+1]=0x20;//事件发生源
				p8tx[Byte+2]=0x24;
				p8tx[Byte+3]=0x02;
				p8tx[Byte+4]=0x00;
				UARTCtrl->RMCSD[7+(4*x)+0]=0x20;
				UARTCtrl->RMCSD[7+(4*x)+1]=0x24;
				UARTCtrl->RMCSD[7+(4*x)+2]=0x02;
				UARTCtrl->RMCSD[7+(4*x)+3]=0x00;
				Byte+=5;
				x++;
		//---当不为全选时  END---
		
				p8tx-=5*x;
				p8tx--;
				p8tx[Byte]=x;//UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				UARTCtrl->RMCSD[0]=DataType_CSD;
				UARTCtrl->RMCSD[1]=1;//记录型对象属性描述符 [1] ROAD
				UARTCtrl->RMCSD[6]=x;
				p8tx++;
				p8tx+=5*x;
			}
			else
			{
				x=UARTCtrl->RMCSD[6];//RCSD，SEQUENCE OF个数
				p8tx[Byte]=x;
				Byte++;
				for(i=0;i<x;i++)
				{
					p8tx[Byte+0]=0;//类型=OAD
					p8tx[Byte+1]=UARTCtrl->RMCSD[7+(i*4)+0];//OAD
					p8tx[Byte+2]=UARTCtrl->RMCSD[7+(i*4)+1];//OAD
					p8tx[Byte+3]=UARTCtrl->RMCSD[7+(i*4)+2];//OAD
					p8tx[Byte+4]=UARTCtrl->RMCSD[7+(i*4)+3];//OAD
					Byte+=5;
				}
			}
			
		//时间标签
			p8tx[Byte]=0;
			Byte+=1;
		//安全模式读取
			p8tx-=3;//空出的3字节
			x=Byte-14;//APDU长度
			i=(UARTCtrl->RMCSD[2]<<8)|UARTCtrl->RMCSD[3];
			i=RM_SECURITY(i);//抄表安全模式字,入口:OI,出口:(同安全请求)b7=0无安全=1安全传输,b6=0明文=1密文,b5=,b4=,b3-b0=0数据验证码[0]SID_MAC =1随机数[1]RN =2随机数+数据MAC[2]RN_MAC =3安全标识[3]SID
			if(i==0)
			{//明文读取
				for(i=0;i<x;i++)
				{
					p8tx[14+i]=p8tx[17+i];
				}
			}
			else
			{//明文+数据验证码读取
				p8tx[14]=0x10;
				p8tx[15]=0;//明文应用数据单元 [0] 密文应用数据单元 [1]
				p8tx[16]=x;//octet-string长度
				Byte+=3;
				p8tx[Byte]=1;//随机数 [1]  RN
				p8tx[Byte+1]=16;//长度
				Byte+=2;
				i=TESAM_CMD_TxRx(0x80040010,0,0);//发送ESAM命令;返回:0=正确发收且返回9000,1=错误
				if(i)
				{
					UART7Ctrl->Task=0;//关电源重启
				}
				MR((u32)p8tx+Byte,ADDR_UART7Rx+5,16);
				MR((u32)&UARTCtrl->Rand,ADDR_UART7Rx+5,16);//抄表安全模式时发送给电表的16字节随机数
				Byte+=16;
			}
		//帧校验FCS  2Byte(是对整帧除起始字符、结束字符和FCS本身之外的所有字节的校验)
		//结束字符（16H）
			Byte+=3;
			Byte-=2;
			p8tx[1]=Byte;
			p8tx[2]=Byte>>8;
			Uart_698_HCSFCS(p8tx);//整帧校验计算(HCS和FCS),同时加结束0x16;返回0=正确，1=错误
			Byte+=2;
			
			p8tx-=4;
			p8tx[0]=0xfe;
			p8tx[1]=0xfe;
			p8tx[2]=0xfe;
			p8tx[3]=0xfe;
			Byte+=4;
		#if (USER/100)==0//电科院测试验
			Uart_3762_AFN13F1_Tx(PORTn,3,(u32)p8tx,Byte,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
		#else
			if(Comm_Ram->RouterType==2)//路由器类型:0=保留,1=正泰,2=鼎信,3=东软,4=晓晨,5=瑞斯康,6=力合微,7=讯能,8=钱龙
			{//鼎信无698暂用透明
				Uart_3762_AFN13F1_Tx(PORTn,0,(u32)p8tx,Byte,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
			}
			else
			{
				Uart_3762_AFN13F1_Tx(PORTn,3,(u32)p8tx,Byte,100,0);//376.2监控从节点数据填入发送区;入口:端口,通信协议(1=1997,2=2007),标准645帧地址,645帧长度,预计应答字节数,通信延时相关标志
			}
		#endif
			p8tx-=256;
		#if SEL_RouterRunMode3ADDR==1//微功率无线发送帧目标地址:0=电能表地址，1=采集器地址
			if(Terminal_Router->RouterRunMode_1==3)//路由运行模式_通信方式：1表示"窄带电力线载波通信"，2表示"宽带电力线载波通信"，3表示"微功率无线通信"，其它取值保留
			{//微功率无线,目标地址用采集器地址
				x=AddrToMeterSetNo((u16*)&UARTCtrl->RMAddr);//搜索通信地址在采集档案配置表中的序号;返回:从0开始的配置序号,>=RMNmax表示无效
				p8Data=(u8*)ADDR_6000_SDRAM+(x*LENper_6000);
				p8Data=Get_Element(p8Data,3,0,0);//计算元素地址
				if((x>=NUM_RMmax)||(p8Data==0))
				{//没找到配置序号
					//UARTCtrl->TaskID=0;
					UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
					UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
					//取主动上报缓存帧
					i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
					if(i)
					{
						MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
						MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
						i--;
						UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
						UARTCtrl->AutoReportTask=3;//跳过暂停路由
						return;
					}
					Terminal_Router->StopFlags&=~(1<<17);//恢复路由
					//Terminal_Router->RouterCtrl=3;//路由器控制0=空,1=重启,2=暂停,3=恢复,4=读状态;完成后自动回到0
					return;
				}
				//d64=MRR((u32)p8Data+4,6);//取配置采集器地址
				d64=Get_TSA_Value(p8Data+3);//得到TSA的不大于6字节通信地址,数据顺序不变,入口:p8=TSA类型后的字节，若无效值则=0
				if((d64!=0)&&(d64!=0xeeeeeeeeeeee))
				{
					d64=R_Inverse(d64,6);//寄存器数据倒序(高低字节调换),入口:Data=寄存器中数据,Byte=需倒序的字节数;返回:倒序后的数据
					MWR(d64,((u32)p8tx)+16,6);//从节点地址(目的地址)
					Uart_3762_CS((u32)p8tx);//和校验计算并写入(同时写入结束0x16)和比较,返回0=正确1=错误,入口接收或发送缓冲
				}
			}
		#endif
			UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
			UARTCtrl->TxToRxTimerOver=Terminal_Router->MaxOverTime*(1000/10);//从节点监控最大超时时间秒
			UARTCtrl->Task=3;//0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			UARTCtrl->ReRMCount=0;//重发计数
			UARTCtrl->AutoReportTask++;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
		case 13://接收698抄读事件
			if(UARTCtrl->Task>=3)//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{
				break;
			}
			i=p8rx[1]+(p8rx[2]<<8);
			if((UARTCtrl->Task!=1)||(i<=16))//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			{//0=空闲,2超时,或确认否认			
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
			#if (USER%100)==0//电科科测试
				UARTCtrl->AutoReportTask=10;//10=发698抄读新增事件
			#else
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
			#endif
				return;
			}
			//1完成接收
			i=MRR(((u32)p8rx)+22,3);
			if(i!=0x113)
			{//AFN=13H,Fn=1
				//继续接收
				p16timer=(u16 *)Get_ADDR_UARTnTimer(PORTn);
				p16timer[0]=1000/10;
				UARTCtrl->RxByte=0;
				UARTCtrl->Task=5;//5=正在接收
				return;
			}
			x=p8rx[28];//返回数据域长度
			if(x==0)
			{//接收数据长度=0
				if(UARTCtrl->ReRMCount<3)
				{//重发计数
					UARTCtrl->ReRMCount++;
					UARTCtrl->TxByte=31+p8tx[28];//发送字节数(半字对齐)
					UARTCtrl->Task=3;//3=启动发送
					break;
				}
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			}
			MR((u32)p8rx,((u32)p8rx)+28+1,x);
			for(i=0;i<x;i++)
			{//去返回645帧的前导0xfe
				if(p8rx[i]!=0xfe)
				{
					if(i!=0)
					{
						MR((u32)p8rx,((u32)p8rx)+i,x-i);
					}
					break;
				}
			}
			UARTCtrl->Task=5;//UART_3762接收发送;0=空闲,1=完成1帧发收,2=接收超时(或错误),3=启动发送,4=正在发送,5=正在接收
			p16timer[0]=30/10;//下帧发送延时
			i=RM_RxDATA_CHECK(PORTn);//帧接收数据检查,比较发收地址、控制码、数据标识、减0x33;返回:0=正确,1=地址错,2=控制码错,3=数据标识错
			if(i!=0)
			{//错误
			#if (USER/100)==0//是电科院测试
				
			#else
				UARTCtrl->Task=0;
				//UARTCtrl->TaskID=0;
				UARTCtrl->CONNECT=0;//DL698连接:0=空,1=启动连接，2=，100=连接,101=抄表中
				UARTCtrl->AutoReportTask=0;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
				//取主动上报缓存帧
				i=UARTCtrl->AutoReportCopyNUM;//主动上报接收已经缓存帧数
				if(i)
				{
					MeterAutoReportStateWord(PORTn,(u8*)ADDR_UART4RxCopy);//主动上报状态字;入口:自动上报接收帧;返回:0=没接受,1=接受
					MR(ADDR_UART4RxCopy,ADDR_UART4RxCopy+LEN_UART4RxCopy,(i-1)*LEN_UART4RxCopy);
					i--;
					UARTCtrl->AutoReportCopyNUM=i;//主动上报接收已经缓存帧数
					UARTCtrl->AutoReportTask=3;//跳过暂停路由
				}
				return;
			#endif
			}
			//if(i==0)
			//{
				DL698_MeterAutoReport_RxDATA(PORTn,p8rx);//DL698读到的电能表主动上报事件数据缓存;返回:错误代码0=正确,1=缓冲1长度不够,2=缓冲2长度不够,3=缓冲中有关长度值错,4=无对应接口类号,5=数组数大于127,6=抄表计数大于最大数
			//}
			UARTCtrl->RMCSDCount++;//抄表计数
			UARTCtrl->AutoReportTask--;//电能表主动上报任务:0=空,1=有主动上报等待读取,2...抄读中
			break;
	//---DL698 END---
	}
}

#endif





